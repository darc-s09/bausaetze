
Thermometer.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000092  00800100  00000f88  0000101c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000f88  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000014c  00800192  00800192  000010ae  2**0
                  ALLOC
  3 .stab         00003798  00000000  00000000  000010b0  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000014eb  00000000  00000000  00004848  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  00005d33  2**0
                  CONTENTS, READONLY
  6 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00005d44  2**2
                  CONTENTS, READONLY
  7 .debug_info   000005f4  00000000  00000000  00005d84  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000005a2  00000000  00000000  00006378  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000001d  00000000  00000000  0000691a  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000208  00000000  00000000  00006937  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 4e 00 	jmp	0x9c	; 0x9c <__ctors_end>
   4:	0c 94 6b 00 	jmp	0xd6	; 0xd6 <__bad_interrupt>
   8:	0c 94 6b 00 	jmp	0xd6	; 0xd6 <__bad_interrupt>
   c:	0c 94 6b 00 	jmp	0xd6	; 0xd6 <__bad_interrupt>
  10:	0c 94 6b 00 	jmp	0xd6	; 0xd6 <__bad_interrupt>
  14:	0c 94 6b 00 	jmp	0xd6	; 0xd6 <__bad_interrupt>
  18:	0c 94 6b 00 	jmp	0xd6	; 0xd6 <__bad_interrupt>
  1c:	0c 94 6b 00 	jmp	0xd6	; 0xd6 <__bad_interrupt>
  20:	0c 94 6b 00 	jmp	0xd6	; 0xd6 <__bad_interrupt>
  24:	0c 94 5a 04 	jmp	0x8b4	; 0x8b4 <__vector_9>
  28:	0c 94 6b 00 	jmp	0xd6	; 0xd6 <__bad_interrupt>
  2c:	0c 94 6b 00 	jmp	0xd6	; 0xd6 <__bad_interrupt>
  30:	0c 94 6b 00 	jmp	0xd6	; 0xd6 <__bad_interrupt>
  34:	0c 94 6b 00 	jmp	0xd6	; 0xd6 <__bad_interrupt>
  38:	0c 94 50 04 	jmp	0x8a0	; 0x8a0 <__vector_14>
  3c:	0c 94 6b 00 	jmp	0xd6	; 0xd6 <__bad_interrupt>
  40:	0c 94 fd 03 	jmp	0x7fa	; 0x7fa <__vector_16>
  44:	0c 94 6b 00 	jmp	0xd6	; 0xd6 <__bad_interrupt>
  48:	0c 94 a2 04 	jmp	0x944	; 0x944 <__vector_18>
  4c:	0c 94 6b 00 	jmp	0xd6	; 0xd6 <__bad_interrupt>
  50:	0c 94 6b 00 	jmp	0xd6	; 0xd6 <__bad_interrupt>
  54:	0c 94 6b 00 	jmp	0xd6	; 0xd6 <__bad_interrupt>
  58:	0c 94 6b 00 	jmp	0xd6	; 0xd6 <__bad_interrupt>
  5c:	0c 94 6b 00 	jmp	0xd6	; 0xd6 <__bad_interrupt>
  60:	0c 94 6b 00 	jmp	0xd6	; 0xd6 <__bad_interrupt>
  64:	0c 94 6b 00 	jmp	0xd6	; 0xd6 <__bad_interrupt>

00000068 <__trampolines_end>:
  68:	d0 00       	.word	0x00d0	; ????
  6a:	d4 00       	.word	0x00d4	; ????
  6c:	da 00       	.word	0x00da	; ????
  6e:	e1 00       	.word	0x00e1	; ????
  70:	e9 00       	.word	0x00e9	; ????
  72:	f2 00       	.word	0x00f2	; ????
  74:	fc 00       	.word	0x00fc	; ????
  76:	ba 01       	movw	r22, r20
  78:	c4 01       	movw	r24, r8
  7a:	ce 01       	movw	r24, r28
  7c:	d8 01       	movw	r26, r16
  7e:	e2 01       	movw	r28, r4
  80:	ec 01       	movw	r28, r24
  82:	f6 01       	movw	r30, r12
  84:	00 02       	muls	r16, r16
  86:	0a 02       	muls	r16, r26
  88:	14 02       	muls	r17, r20
  8a:	1e 02       	muls	r17, r30
  8c:	28 02       	muls	r18, r24
  8e:	32 02       	muls	r19, r18
  90:	3c 02       	muls	r19, r28
  92:	46 02       	muls	r20, r22
  94:	50 02       	muls	r21, r16
  96:	5a 02       	muls	r21, r26
  98:	64 02       	muls	r22, r20
  9a:	6e 02       	muls	r22, r30

0000009c <__ctors_end>:
  9c:	11 24       	eor	r1, r1
  9e:	1f be       	out	0x3f, r1	; 63
  a0:	cf ef       	ldi	r28, 0xFF	; 255
  a2:	d4 e0       	ldi	r29, 0x04	; 4
  a4:	de bf       	out	0x3e, r29	; 62
  a6:	cd bf       	out	0x3d, r28	; 61

000000a8 <__do_copy_data>:
  a8:	11 e0       	ldi	r17, 0x01	; 1
  aa:	a0 e0       	ldi	r26, 0x00	; 0
  ac:	b1 e0       	ldi	r27, 0x01	; 1
  ae:	e8 e8       	ldi	r30, 0x88	; 136
  b0:	ff e0       	ldi	r31, 0x0F	; 15
  b2:	02 c0       	rjmp	.+4      	; 0xb8 <__do_copy_data+0x10>
  b4:	05 90       	lpm	r0, Z+
  b6:	0d 92       	st	X+, r0
  b8:	a2 39       	cpi	r26, 0x92	; 146
  ba:	b1 07       	cpc	r27, r17
  bc:	d9 f7       	brne	.-10     	; 0xb4 <__do_copy_data+0xc>

000000be <__do_clear_bss>:
  be:	22 e0       	ldi	r18, 0x02	; 2
  c0:	a2 e9       	ldi	r26, 0x92	; 146
  c2:	b1 e0       	ldi	r27, 0x01	; 1
  c4:	01 c0       	rjmp	.+2      	; 0xc8 <.do_clear_bss_start>

000000c6 <.do_clear_bss_loop>:
  c6:	1d 92       	st	X+, r1

000000c8 <.do_clear_bss_start>:
  c8:	ae 3d       	cpi	r26, 0xDE	; 222
  ca:	b2 07       	cpc	r27, r18
  cc:	e1 f7       	brne	.-8      	; 0xc6 <.do_clear_bss_loop>
  ce:	0e 94 9d 02 	call	0x53a	; 0x53a <main>
  d2:	0c 94 c2 07 	jmp	0xf84	; 0xf84 <_exit>

000000d6 <__bad_interrupt>:
  d6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000da <multi_player>:
case 2 Aufruf Spieler 2
                                                                     
******************************************************************************/
void multi_player(uint8_t playernr)
        {
	    sbi(TEMP_OFF,FLAGS);			// Temperaturanzeige AUS 
  da:	90 91 c5 01 	lds	r25, 0x01C5
  de:	29 2f       	mov	r18, r25
  e0:	24 60       	ori	r18, 0x04	; 4
  e2:	20 93 c5 01 	sts	0x01C5, r18
		ztemp = zufall;
  e6:	20 91 92 01 	lds	r18, 0x0192
  ea:	20 93 93 01 	sts	0x0193, r18
  ee:	e9 e9       	ldi	r30, 0x99	; 153
  f0:	f1 e0       	ldi	r31, 0x01	; 1
  f2:	2d ea       	ldi	r18, 0xAD	; 173
  f4:	31 e0       	ldi	r19, 0x01	; 1
		for (uint8_t step = 1; step <= 10 ; step++)
		       {
			   LED_TASK[step][0]=0; //LEDs 1 bis 10 aus
  f6:	10 82       	st	Z, r1
  f8:	32 96       	adiw	r30, 0x02	; 2
******************************************************************************/
void multi_player(uint8_t playernr)
        {
	    sbi(TEMP_OFF,FLAGS);			// Temperaturanzeige AUS 
		ztemp = zufall;
		for (uint8_t step = 1; step <= 10 ; step++)
  fa:	e2 17       	cp	r30, r18
  fc:	f3 07       	cpc	r31, r19
  fe:	d9 f7       	brne	.-10     	; 0xf6 <multi_player+0x1c>
		       {
			   LED_TASK[step][0]=0; //LEDs 1 bis 10 aus
		       }
		LED_TASK[18][0]=0; // LED 10 AUS
 100:	e7 e9       	ldi	r30, 0x97	; 151
 102:	f1 e0       	ldi	r31, 0x01	; 1
 104:	14 a2       	std	Z+36, r1	; 0x24
		LED_TASK[19][0]=0; // LED 19 AUS	
 106:	16 a2       	std	Z+38, r1	; 0x26
		
	    switch(playernr)
 108:	81 30       	cpi	r24, 0x01	; 1
 10a:	99 f0       	breq	.+38     	; 0x132 <multi_player+0x58>
 10c:	82 30       	cpi	r24, 0x02	; 2
 10e:	21 f1       	breq	.+72     	; 0x158 <multi_player+0x7e>
 110:	88 23       	and	r24, r24
 112:	51 f0       	breq	.+20     	; 0x128 <multi_player+0x4e>
#if UART_DEBUG == 1
			errorcodeu(player2); // DEBUG
#endif
			break;
			}
		drehaktiv = rand()%6+1;
 114:	0e 94 4f 07 	call	0xe9e	; 0xe9e <rand>
 118:	66 e0       	ldi	r22, 0x06	; 6
 11a:	70 e0       	ldi	r23, 0x00	; 0
 11c:	0e 94 b9 06 	call	0xd72	; 0xd72 <__divmodhi4>
 120:	8f 5f       	subi	r24, 0xFF	; 255
 122:	80 93 c8 01 	sts	0x01C8, r24
        }
 126:	08 95       	ret
		LED_TASK[19][0]=0; // LED 19 AUS	
		
	    switch(playernr)
			{
			case 0:
			player1 = 0;
 128:	10 92 95 01 	sts	0x0195, r1
			player2 = 0;
 12c:	10 92 c4 01 	sts	0x01C4, r1
			break;	
 130:	f1 cf       	rjmp	.-30     	; 0x114 <multi_player+0x3a>
			case 1:
			cbi(PLAYER,FLAGS); // PLAYER 1
 132:	9f 7e       	andi	r25, 0xEF	; 239
 134:	94 60       	ori	r25, 0x04	; 4
 136:	90 93 c5 01 	sts	0x01C5, r25
			LED_TASK[18][0]=1; // LED 10 AN
 13a:	81 e0       	ldi	r24, 0x01	; 1
 13c:	80 93 bb 01 	sts	0x01BB, r24
			LED_TASK[19][0]=0; // LED 19 AUS
			player1 = player1 + ztemp;
 140:	80 91 95 01 	lds	r24, 0x0195
 144:	90 91 93 01 	lds	r25, 0x0193
 148:	89 0f       	add	r24, r25
 14a:	80 93 95 01 	sts	0x0195, r24
#if UART_DEBUG == 1
			errorcodeu(player1); // DEBUG
 14e:	80 91 95 01 	lds	r24, 0x0195
 152:	0e 94 f1 04 	call	0x9e2	; 0x9e2 <errorcodeu>
#endif			
			break;
 156:	de cf       	rjmp	.-68     	; 0x114 <multi_player+0x3a>
			case 2:
			sbi(PLAYER,FLAGS); // PLAYER 2
 158:	94 61       	ori	r25, 0x14	; 20
 15a:	90 93 c5 01 	sts	0x01C5, r25
			LED_TASK[18][0]=0; // LED 10 AUS
			LED_TASK[19][0]=1; // LED 19 AN
 15e:	81 e0       	ldi	r24, 0x01	; 1
 160:	80 93 bd 01 	sts	0x01BD, r24
			player2 = player2 + ztemp;
 164:	80 91 c4 01 	lds	r24, 0x01C4
 168:	90 91 93 01 	lds	r25, 0x0193
 16c:	89 0f       	add	r24, r25
 16e:	80 93 c4 01 	sts	0x01C4, r24
#if UART_DEBUG == 1
			errorcodeu(player2); // DEBUG
 172:	80 91 c4 01 	lds	r24, 0x01C4
 176:	0e 94 f1 04 	call	0x9e2	; 0x9e2 <errorcodeu>
#endif
			break;
 17a:	cc cf       	rjmp	.-104    	; 0x114 <multi_player+0x3a>

0000017c <wuerfel>:
***************************************************************************************/
void wuerfel(uint8_t wzahl)
{
for (uint8_t step = 11; step <= 17 ; step++)    // Abschalten aller 7 LED`s
    {
    LED_TASK[step][0]=0;                        // Abschalten aller LED`s auf dem Wuerfelfeld
 17c:	e7 e9       	ldi	r30, 0x97	; 151
 17e:	f1 e0       	ldi	r31, 0x01	; 1
 180:	16 8a       	std	Z+22, r1	; 0x16
 182:	10 8e       	std	Z+24, r1	; 0x18
 184:	12 8e       	std	Z+26, r1	; 0x1a
 186:	14 8e       	std	Z+28, r1	; 0x1c
 188:	16 8e       	std	Z+30, r1	; 0x1e
 18a:	10 a2       	std	Z+32, r1	; 0x20
 18c:	12 a2       	std	Z+34, r1	; 0x22
 18e:	81 50       	subi	r24, 0x01	; 1
 190:	87 30       	cpi	r24, 0x07	; 7
 192:	e0 f5       	brcc	.+120    	; 0x20c <wuerfel+0x90>
 194:	e8 2f       	mov	r30, r24
 196:	f0 e0       	ldi	r31, 0x00	; 0
 198:	ec 5c       	subi	r30, 0xCC	; 204
 19a:	ff 4f       	sbci	r31, 0xFF	; 255
 19c:	0c 94 cd 06 	jmp	0xd9a	; 0xd9a <__tablejump2__>
    }
switch (wzahl)
    {
    case 1:                 // Wuerfel Zahl 1
    LED_TASK[11][0]=1;      // Wuerfel Zahl 1 >  LED 11
 1a0:	81 e0       	ldi	r24, 0x01	; 1
 1a2:	80 93 ad 01 	sts	0x01AD, r24
    break;                  // Ende case
 1a6:	08 95       	ret

    case 2:                 // Wuerfel Zahl 2
    LED_TASK[14][0]=1;      // Wuerfel Zahl 2 >  LED 14
 1a8:	e7 e9       	ldi	r30, 0x97	; 151
 1aa:	f1 e0       	ldi	r31, 0x01	; 1
 1ac:	81 e0       	ldi	r24, 0x01	; 1
 1ae:	84 8f       	std	Z+28, r24	; 0x1c
    LED_TASK[16][0]=1;      // Wuerfel Zahl 2 >  LED 16
 1b0:	80 a3       	std	Z+32, r24	; 0x20
    break;                  // Ende case
 1b2:	08 95       	ret

    case 3:                 // Wuerfel Zahl 3
    LED_TASK[11][0]=1;      // Wuerfel Zahl 3 >  LED 11
 1b4:	e7 e9       	ldi	r30, 0x97	; 151
 1b6:	f1 e0       	ldi	r31, 0x01	; 1
 1b8:	81 e0       	ldi	r24, 0x01	; 1
 1ba:	86 8b       	std	Z+22, r24	; 0x16
    LED_TASK[14][0]=1;      // Wuerfel Zahl 3 >  LED 14
 1bc:	84 8f       	std	Z+28, r24	; 0x1c
    LED_TASK[16][0]=1;      // Wuerfel Zahl 3 >  LED 16
 1be:	80 a3       	std	Z+32, r24	; 0x20
    break;                  // Ende case
 1c0:	08 95       	ret

    case 4:                 // Wuerfel Zahl 4
    LED_TASK[14][0]=1;      // Wuerfel Zahl 4 >  LED 14
 1c2:	e7 e9       	ldi	r30, 0x97	; 151
 1c4:	f1 e0       	ldi	r31, 0x01	; 1
 1c6:	81 e0       	ldi	r24, 0x01	; 1
 1c8:	84 8f       	std	Z+28, r24	; 0x1c
    LED_TASK[15][0]=1;      // Wuerfel Zahl 4 >  LED 15
 1ca:	86 8f       	std	Z+30, r24	; 0x1e
    LED_TASK[16][0]=1;      // Wuerfel Zahl 4 >  LED 16
 1cc:	80 a3       	std	Z+32, r24	; 0x20
    LED_TASK[17][0]=1;      // Wuerfel Zahl 4 >  LED 17
 1ce:	82 a3       	std	Z+34, r24	; 0x22
    break;                  // Ende case
 1d0:	08 95       	ret

    case 5:                 // Wuerfel Zahl 5
    LED_TASK[11][0]=1;      // Wuerfel Zahl 5 >  LED 11
 1d2:	e7 e9       	ldi	r30, 0x97	; 151
 1d4:	f1 e0       	ldi	r31, 0x01	; 1
 1d6:	81 e0       	ldi	r24, 0x01	; 1
 1d8:	86 8b       	std	Z+22, r24	; 0x16
    LED_TASK[14][0]=1;      // Wuerfel Zahl 5 >  LED 14
 1da:	84 8f       	std	Z+28, r24	; 0x1c
    LED_TASK[15][0]=1;      // Wuerfel Zahl 5 >  LED 15
 1dc:	86 8f       	std	Z+30, r24	; 0x1e
    LED_TASK[16][0]=1;      // Wuerfel Zahl 5 >  LED 16
 1de:	80 a3       	std	Z+32, r24	; 0x20
    LED_TASK[17][0]=1;      // Wuerfel Zahl 5 >  LED 17
 1e0:	82 a3       	std	Z+34, r24	; 0x22
    break;                  // Ende case
 1e2:	08 95       	ret

    case 6:                 // Wuerfel Zahl 6
    LED_TASK[12][0]=1;      // Wuerfel Zahl 6 >  LED 12
 1e4:	e7 e9       	ldi	r30, 0x97	; 151
 1e6:	f1 e0       	ldi	r31, 0x01	; 1
 1e8:	81 e0       	ldi	r24, 0x01	; 1
 1ea:	80 8f       	std	Z+24, r24	; 0x18
    LED_TASK[13][0]=1;      // Wuerfel Zahl 6 >  LED 13
 1ec:	82 8f       	std	Z+26, r24	; 0x1a
    LED_TASK[14][0]=1;      // Wuerfel Zahl 6 >  LED 14
 1ee:	84 8f       	std	Z+28, r24	; 0x1c
    LED_TASK[15][0]=1;      // Wuerfel Zahl 6 >  LED 15
 1f0:	86 8f       	std	Z+30, r24	; 0x1e
    LED_TASK[16][0]=1;      // Wuerfel Zahl 6 >  LED 16
 1f2:	80 a3       	std	Z+32, r24	; 0x20
    LED_TASK[17][0]=1;      // Wuerfel Zahl 6 >  LED 17
 1f4:	82 a3       	std	Z+34, r24	; 0x22
    break;                  // Ende case
 1f6:	08 95       	ret

    case 7:                 // Wuerfel Zahl 7
    LED_TASK[11][0]=1;      // Wuerfel Zahl 7 >  LED 11
 1f8:	e7 e9       	ldi	r30, 0x97	; 151
 1fa:	f1 e0       	ldi	r31, 0x01	; 1
 1fc:	81 e0       	ldi	r24, 0x01	; 1
 1fe:	86 8b       	std	Z+22, r24	; 0x16
    LED_TASK[12][0]=1;      // Wuerfel Zahl 7 >  LED 12
 200:	80 8f       	std	Z+24, r24	; 0x18
    LED_TASK[13][0]=1;      // Wuerfel Zahl 7 >  LED 13
 202:	82 8f       	std	Z+26, r24	; 0x1a
    LED_TASK[14][0]=1;      // Wuerfel Zahl 7 >  LED 14
 204:	84 8f       	std	Z+28, r24	; 0x1c
    LED_TASK[15][0]=1;      // Wuerfel Zahl 7 >  LED 15
 206:	86 8f       	std	Z+30, r24	; 0x1e
    LED_TASK[16][0]=1;      // Wuerfel Zahl 7 >  LED 16
 208:	80 a3       	std	Z+32, r24	; 0x20
    LED_TASK[17][0]=1;      // Wuerfel Zahl 7 >  LED 17
 20a:	82 a3       	std	Z+34, r24	; 0x22
    break;                  // Ende case

    }

}
 20c:	08 95       	ret

0000020e <drehenr>:
***************************************************************************************/
void drehenr(uint8_t wstep)
{
for (uint8_t step = 11; step <= 17 ; step++)    // Abschalten aller 7 LED`s
    {
    LED_TASK[step][0]=0;                        // Abschalten aller LED`s auf dem Wuerfelfeld
 20e:	e7 e9       	ldi	r30, 0x97	; 151
 210:	f1 e0       	ldi	r31, 0x01	; 1
 212:	16 8a       	std	Z+22, r1	; 0x16
 214:	10 8e       	std	Z+24, r1	; 0x18
 216:	12 8e       	std	Z+26, r1	; 0x1a
 218:	14 8e       	std	Z+28, r1	; 0x1c
 21a:	16 8e       	std	Z+30, r1	; 0x1e
 21c:	10 a2       	std	Z+32, r1	; 0x20
 21e:	12 a2       	std	Z+34, r1	; 0x22
    }
switch (wstep)
 220:	84 30       	cpi	r24, 0x04	; 4
 222:	49 f1       	breq	.+82     	; 0x276 <drehenr+0x68>
 224:	a8 f4       	brcc	.+42     	; 0x250 <drehenr+0x42>
 226:	82 30       	cpi	r24, 0x02	; 2
 228:	f9 f0       	breq	.+62     	; 0x268 <drehenr+0x5a>
 22a:	83 30       	cpi	r24, 0x03	; 3
 22c:	39 f4       	brne	.+14     	; 0x23c <drehenr+0x2e>
    LED_TASK[15][0]=1;      // LED 15
    LED_TASK[17][0]=1;      // LED 17
    break;                  // Ende case

    case 3:                 // Step 3 /
    LED_TASK[11][0]=1;      // LED 11
 22e:	e7 e9       	ldi	r30, 0x97	; 151
 230:	f1 e0       	ldi	r31, 0x01	; 1
 232:	81 e0       	ldi	r24, 0x01	; 1
 234:	86 8b       	std	Z+22, r24	; 0x16
    LED_TASK[14][0]=1;      // LED 14
 236:	84 8f       	std	Z+28, r24	; 0x1c
    LED_TASK[16][0]=1;      // LED 16
 238:	80 a3       	std	Z+32, r24	; 0x20
    break;                  // Ende case
 23a:	08 95       	ret
{
for (uint8_t step = 11; step <= 17 ; step++)    // Abschalten aller 7 LED`s
    {
    LED_TASK[step][0]=0;                        // Abschalten aller LED`s auf dem Wuerfelfeld
    }
switch (wstep)
 23c:	81 30       	cpi	r24, 0x01	; 1
 23e:	39 f4       	brne	.+14     	; 0x24e <drehenr+0x40>
    {
    case 1:                 // Step 1 -
    LED_TASK[11][0]=1;      // LED 11
 240:	e7 e9       	ldi	r30, 0x97	; 151
 242:	f1 e0       	ldi	r31, 0x01	; 1
 244:	81 e0       	ldi	r24, 0x01	; 1
 246:	86 8b       	std	Z+22, r24	; 0x16
    LED_TASK[12][0]=1;      // LED 12
 248:	80 8f       	std	Z+24, r24	; 0x18
    LED_TASK[13][0]=1;      // LED 13
 24a:	82 8f       	std	Z+26, r24	; 0x1a
    break;                  // Ende case
 24c:	08 95       	ret
 24e:	08 95       	ret
{
for (uint8_t step = 11; step <= 17 ; step++)    // Abschalten aller 7 LED`s
    {
    LED_TASK[step][0]=0;                        // Abschalten aller LED`s auf dem Wuerfelfeld
    }
switch (wstep)
 250:	85 30       	cpi	r24, 0x05	; 5
 252:	c1 f0       	breq	.+48     	; 0x284 <drehenr+0x76>
 254:	86 30       	cpi	r24, 0x06	; 6
 256:	39 f4       	brne	.+14     	; 0x266 <drehenr+0x58>
    LED_TASK[15][0]=1;      // LED 15
    LED_TASK[17][0]=1;      // LED 17
    break;                  // Ende case

    case 6:                 // Step 6 /
    LED_TASK[11][0]=1;      // LED 11
 258:	e7 e9       	ldi	r30, 0x97	; 151
 25a:	f1 e0       	ldi	r31, 0x01	; 1
 25c:	81 e0       	ldi	r24, 0x01	; 1
 25e:	86 8b       	std	Z+22, r24	; 0x16
    LED_TASK[14][0]=1;      // LED 14
 260:	84 8f       	std	Z+28, r24	; 0x1c
    LED_TASK[16][0]=1;      // LED 16
 262:	80 a3       	std	Z+32, r24	; 0x20
    break;                  // Ende case

    }
}
 264:	08 95       	ret
 266:	08 95       	ret
    LED_TASK[12][0]=1;      // LED 12
    LED_TASK[13][0]=1;      // LED 13
    break;                  // Ende case

    case 2:                 // Step 2 nr
    LED_TASK[11][0]=1;      // LED 11
 268:	e7 e9       	ldi	r30, 0x97	; 151
 26a:	f1 e0       	ldi	r31, 0x01	; 1
 26c:	81 e0       	ldi	r24, 0x01	; 1
 26e:	86 8b       	std	Z+22, r24	; 0x16
    LED_TASK[15][0]=1;      // LED 15
 270:	86 8f       	std	Z+30, r24	; 0x1e
    LED_TASK[17][0]=1;      // LED 17
 272:	82 a3       	std	Z+34, r24	; 0x22
    break;                  // Ende case
 274:	08 95       	ret
    LED_TASK[14][0]=1;      // LED 14
    LED_TASK[16][0]=1;      // LED 16
    break;                  // Ende case

    case 4:                 // Step 4 -
    LED_TASK[11][0]=1;      // LED 11
 276:	e7 e9       	ldi	r30, 0x97	; 151
 278:	f1 e0       	ldi	r31, 0x01	; 1
 27a:	81 e0       	ldi	r24, 0x01	; 1
 27c:	86 8b       	std	Z+22, r24	; 0x16
    LED_TASK[12][0]=1;      // LED 12
 27e:	80 8f       	std	Z+24, r24	; 0x18
    LED_TASK[13][0]=1;      // LED 13
 280:	82 8f       	std	Z+26, r24	; 0x1a
    break;                  // Ende case
 282:	08 95       	ret

    case 5:                 // Step 5 nr
    LED_TASK[11][0]=1;      // LED 11
 284:	e7 e9       	ldi	r30, 0x97	; 151
 286:	f1 e0       	ldi	r31, 0x01	; 1
 288:	81 e0       	ldi	r24, 0x01	; 1
 28a:	86 8b       	std	Z+22, r24	; 0x16
    LED_TASK[15][0]=1;      // LED 15
 28c:	86 8f       	std	Z+30, r24	; 0x1e
    LED_TASK[17][0]=1;      // LED 17
 28e:	82 a3       	std	Z+34, r24	; 0x22
    break;                  // Ende case
 290:	08 95       	ret

00000292 <wuerfellos>:
 Parameteruebergabe:
 drehg (Geschwindigkeit des Zeigers)
Die Variable wzeiger bestimmt die Geschwindigkeit und wird im Timer2 hochgezaehlt
******************************************************************************/
void wuerfellos(uint8_t drehg)
{
 292:	28 2f       	mov	r18, r24
	if (qbi (drehg,wzeiger))
 294:	40 91 c6 01 	lds	r20, 0x01C6
 298:	50 91 c7 01 	lds	r21, 0x01C7
 29c:	81 e0       	ldi	r24, 0x01	; 1
 29e:	90 e0       	ldi	r25, 0x00	; 0
 2a0:	02 2e       	mov	r0, r18
 2a2:	02 c0       	rjmp	.+4      	; 0x2a8 <wuerfellos+0x16>
 2a4:	88 0f       	add	r24, r24
 2a6:	99 1f       	adc	r25, r25
 2a8:	0a 94       	dec	r0
 2aa:	e2 f7       	brpl	.-8      	; 0x2a4 <wuerfellos+0x12>
 2ac:	84 23       	and	r24, r20
 2ae:	95 23       	and	r25, r21
 2b0:	02 c0       	rjmp	.+4      	; 0x2b6 <wuerfellos+0x24>
 2b2:	96 95       	lsr	r25
 2b4:	87 95       	ror	r24
 2b6:	2a 95       	dec	r18
 2b8:	e2 f7       	brpl	.-8      	; 0x2b2 <wuerfellos+0x20>
 2ba:	89 2b       	or	r24, r25
 2bc:	29 f4       	brne	.+10     	; 0x2c8 <wuerfellos+0x36>
		{
			drehcounter = 1;
			drehaktiv--;
		}
	}
	if (!drehaktiv)
 2be:	80 91 c8 01 	lds	r24, 0x01C8
 2c2:	88 23       	and	r24, r24
 2c4:	d9 f0       	breq	.+54     	; 0x2fc <wuerfellos+0x6a>
        {
		wuerfel(ztemp);
        }
}
 2c6:	08 95       	ret
******************************************************************************/
void wuerfellos(uint8_t drehg)
{
	if (qbi (drehg,wzeiger))
	{
		wzeiger = 0;
 2c8:	10 92 c7 01 	sts	0x01C7, r1
 2cc:	10 92 c6 01 	sts	0x01C6, r1
		drehenr(drehcounter);
 2d0:	80 91 c1 01 	lds	r24, 0x01C1
 2d4:	0e 94 07 01 	call	0x20e	; 0x20e <drehenr>
		drehcounter++;
 2d8:	80 91 c1 01 	lds	r24, 0x01C1
 2dc:	8f 5f       	subi	r24, 0xFF	; 255
 2de:	80 93 c1 01 	sts	0x01C1, r24
		if (drehcounter >= 7)
 2e2:	80 91 c1 01 	lds	r24, 0x01C1
 2e6:	87 30       	cpi	r24, 0x07	; 7
 2e8:	50 f3       	brcs	.-44     	; 0x2be <wuerfellos+0x2c>
		{
			drehcounter = 1;
 2ea:	81 e0       	ldi	r24, 0x01	; 1
 2ec:	80 93 c1 01 	sts	0x01C1, r24
			drehaktiv--;
 2f0:	80 91 c8 01 	lds	r24, 0x01C8
 2f4:	81 50       	subi	r24, 0x01	; 1
 2f6:	80 93 c8 01 	sts	0x01C8, r24
 2fa:	e1 cf       	rjmp	.-62     	; 0x2be <wuerfellos+0x2c>
		}
	}
	if (!drehaktiv)
        {
		wuerfel(ztemp);
 2fc:	80 91 93 01 	lds	r24, 0x0193
 300:	0e 94 be 00 	call	0x17c	; 0x17c <wuerfel>
        }
}
 304:	e0 cf       	rjmp	.-64     	; 0x2c6 <wuerfellos+0x34>

00000306 <ledband>:
/******************************************************************************
Ansteuerung LED Band auf Basis AD Wandler
******************************************************************************/

void ledband(uint16_t tempwert, uint16_t tempset)
{
 306:	28 2f       	mov	r18, r24
 308:	39 2f       	mov	r19, r25
 30a:	86 2f       	mov	r24, r22
 30c:	97 2f       	mov	r25, r23
if ( tempwert < tempset)
 30e:	28 17       	cp	r18, r24
 310:	39 07       	cpc	r19, r25
 312:	38 f0       	brcs	.+14     	; 0x322 <ledband+0x1c>
 314:	01 96       	adiw	r24, 0x01	; 1
 316:	e9 e9       	ldi	r30, 0x99	; 153
 318:	f1 e0       	ldi	r31, 0x01	; 1
 31a:	4d ea       	ldi	r20, 0xAD	; 173
 31c:	51 e0       	ldi	r21, 0x01	; 1
for (uint8_t step = 0; step <= 9 ; step++)      // Zur Ansteuerung des LED Temperaturbandes
    {
    tempset++; //
    if ( (tempwert >= tempset) && (tempwert <= (tempset + 2)) ) // Hier wird festgelegt in welchen Bereich die LED's zugeschaltet werden.
        {
        LED_TASK[step+1][0]=1;                  // Zuschalten LED auf den Band
 31e:	a1 e0       	ldi	r26, 0x01	; 1
 320:	13 c0       	rjmp	.+38     	; 0x348 <ledband+0x42>
{
if ( tempwert < tempset)
    {
    for (uint8_t step = 0; step <= 9 ; step++)  // Fuer Testzwecke werden die Daten als Binaere Zahl auf die LED`s 1 bis 10 geschrieben.
        {
        LED_TASK[step+1][0]=0;                  // Abschalten aller LED`s der Temperaturanzeige
 322:	e7 e9       	ldi	r30, 0x97	; 151
 324:	f1 e0       	ldi	r31, 0x01	; 1
 326:	12 82       	std	Z+2, r1	; 0x02
 328:	14 82       	std	Z+4, r1	; 0x04
 32a:	16 82       	std	Z+6, r1	; 0x06
 32c:	10 86       	std	Z+8, r1	; 0x08
 32e:	12 86       	std	Z+10, r1	; 0x0a
 330:	14 86       	std	Z+12, r1	; 0x0c
 332:	16 86       	std	Z+14, r1	; 0x0e
 334:	10 8a       	std	Z+16, r1	; 0x10
 336:	12 8a       	std	Z+18, r1	; 0x12
 338:	14 8a       	std	Z+20, r1	; 0x14
 33a:	ec cf       	rjmp	.-40     	; 0x314 <ledband+0xe>
        {
        LED_TASK[step+1][0]=1;                  // Zuschalten LED auf den Band
        }
    else
        {
        LED_TASK[step+1][0]=0;                  // Abschalten der nichtaktiven LED auf den Band
 33c:	10 82       	st	Z, r1
 33e:	02 96       	adiw	r24, 0x02	; 2
 340:	32 96       	adiw	r30, 0x02	; 2
        }
    }



for (uint8_t step = 0; step <= 9 ; step++)      // Zur Ansteuerung des LED Temperaturbandes
 342:	4e 17       	cp	r20, r30
 344:	5f 07       	cpc	r21, r31
 346:	59 f0       	breq	.+22     	; 0x35e <ledband+0x58>
    {
    tempset++; //
    if ( (tempwert >= tempset) && (tempwert <= (tempset + 2)) ) // Hier wird festgelegt in welchen Bereich die LED's zugeschaltet werden.
 348:	28 17       	cp	r18, r24
 34a:	39 07       	cpc	r19, r25
 34c:	b8 f3       	brcs	.-18     	; 0x33c <ledband+0x36>
 34e:	bc 01       	movw	r22, r24
 350:	6e 5f       	subi	r22, 0xFE	; 254
 352:	7f 4f       	sbci	r23, 0xFF	; 255
 354:	62 17       	cp	r22, r18
 356:	73 07       	cpc	r23, r19
 358:	88 f3       	brcs	.-30     	; 0x33c <ledband+0x36>
        {
        LED_TASK[step+1][0]=1;                  // Zuschalten LED auf den Band
 35a:	a0 83       	st	Z, r26
 35c:	f0 cf       	rjmp	.-32     	; 0x33e <ledband+0x38>
    tempset++;
    }



}
 35e:	08 95       	ret

00000360 <zeilenwahl>:
/******************************************************************************
Ansteuerung der LED im Multiplex Verfahren
Das Timing wird per Timer Interrupt gesteuert
******************************************************************************/
void zeilenwahl(uint8_t zeile)
{
 360:	81 50       	subi	r24, 0x01	; 1
 362:	83 31       	cpi	r24, 0x13	; 19
 364:	08 f0       	brcs	.+2      	; 0x368 <zeilenwahl+0x8>
 366:	c4 c0       	rjmp	.+392    	; 0x4f0 <zeilenwahl+0x190>
 368:	e8 2f       	mov	r30, r24
 36a:	f0 e0       	ldi	r31, 0x00	; 0
 36c:	e5 5c       	subi	r30, 0xC5	; 197
 36e:	ff 4f       	sbci	r31, 0xFF	; 255
 370:	0c 94 cd 06 	jmp	0xd9a	; 0xd9a <__tablejump2__>

 switch (zeile)
    {
     case 1:
     ZEILE1_ON;     // LED1 AN
 374:	22 9a       	sbi	0x04, 2	; 4
     ZEILE2_OFF;
 376:	21 98       	cbi	0x04, 1	; 4
     ZEILE3_OFF;
 378:	20 98       	cbi	0x04, 0	; 4
     ZEILE4_OFF;
 37a:	57 98       	cbi	0x0a, 7	; 10
     SPALTE1_ON;
 37c:	5e 9a       	sbi	0x0b, 6	; 11
     SPALTE2_OFF;
 37e:	5d 98       	cbi	0x0b, 5	; 11
     SPALTE3_OFF;
 380:	5c 98       	cbi	0x0b, 4	; 11
     SPALTE4_OFF;
 382:	5b 98       	cbi	0x0b, 3	; 11
     SPALTE5_OFF;
 384:	5a 98       	cbi	0x0b, 2	; 11
     break;
 386:	08 95       	ret
     case 2:
     ZEILE1_ON;     // LED2 AN
 388:	22 9a       	sbi	0x04, 2	; 4
     ZEILE2_OFF;
 38a:	21 98       	cbi	0x04, 1	; 4
     ZEILE3_OFF;
 38c:	20 98       	cbi	0x04, 0	; 4
     ZEILE4_OFF;
 38e:	57 98       	cbi	0x0a, 7	; 10
     SPALTE1_OFF;
 390:	5e 98       	cbi	0x0b, 6	; 11
     SPALTE2_ON;
 392:	5d 9a       	sbi	0x0b, 5	; 11
     SPALTE3_OFF;
 394:	5c 98       	cbi	0x0b, 4	; 11
     SPALTE4_OFF;
 396:	5b 98       	cbi	0x0b, 3	; 11
     SPALTE5_OFF;
 398:	5a 98       	cbi	0x0b, 2	; 11
     break;
 39a:	08 95       	ret
     case 3:
      ZEILE1_ON;        // LED3 AN
 39c:	22 9a       	sbi	0x04, 2	; 4
      ZEILE2_OFF;
 39e:	21 98       	cbi	0x04, 1	; 4
      ZEILE3_OFF;
 3a0:	20 98       	cbi	0x04, 0	; 4
      ZEILE4_OFF;
 3a2:	57 98       	cbi	0x0a, 7	; 10
      SPALTE1_OFF;
 3a4:	5e 98       	cbi	0x0b, 6	; 11
      SPALTE2_OFF;
 3a6:	5d 98       	cbi	0x0b, 5	; 11
      SPALTE3_ON;
 3a8:	5c 9a       	sbi	0x0b, 4	; 11
      SPALTE4_OFF;
 3aa:	5b 98       	cbi	0x0b, 3	; 11
      SPALTE5_OFF;
 3ac:	5a 98       	cbi	0x0b, 2	; 11
     break;
 3ae:	08 95       	ret
     case 4:
      ZEILE1_ON;        // LED4 AN
 3b0:	22 9a       	sbi	0x04, 2	; 4
      ZEILE2_OFF;
 3b2:	21 98       	cbi	0x04, 1	; 4
      ZEILE3_OFF;
 3b4:	20 98       	cbi	0x04, 0	; 4
      ZEILE4_OFF;
 3b6:	57 98       	cbi	0x0a, 7	; 10
      SPALTE1_OFF;
 3b8:	5e 98       	cbi	0x0b, 6	; 11
      SPALTE2_OFF;
 3ba:	5d 98       	cbi	0x0b, 5	; 11
      SPALTE3_OFF;
 3bc:	5c 98       	cbi	0x0b, 4	; 11
      SPALTE4_ON;
 3be:	5b 9a       	sbi	0x0b, 3	; 11
      SPALTE5_OFF;
 3c0:	5a 98       	cbi	0x0b, 2	; 11
     break;
 3c2:	08 95       	ret
     case 5:
     ZEILE1_ON;     // LED5 AN
 3c4:	22 9a       	sbi	0x04, 2	; 4
     ZEILE2_OFF;
 3c6:	21 98       	cbi	0x04, 1	; 4
     ZEILE3_OFF;
 3c8:	20 98       	cbi	0x04, 0	; 4
     ZEILE4_OFF;
 3ca:	57 98       	cbi	0x0a, 7	; 10
     SPALTE1_OFF;
 3cc:	5e 98       	cbi	0x0b, 6	; 11
     SPALTE2_OFF;
 3ce:	5d 98       	cbi	0x0b, 5	; 11
     SPALTE3_OFF;
 3d0:	5c 98       	cbi	0x0b, 4	; 11
     SPALTE4_OFF;
 3d2:	5b 98       	cbi	0x0b, 3	; 11
     SPALTE5_ON;
 3d4:	5a 9a       	sbi	0x0b, 2	; 11
     break;
 3d6:	08 95       	ret
     case 6:
     ZEILE1_OFF;        // LED6 AN
 3d8:	22 98       	cbi	0x04, 2	; 4
     ZEILE2_ON;
 3da:	21 9a       	sbi	0x04, 1	; 4
     ZEILE3_OFF;
 3dc:	20 98       	cbi	0x04, 0	; 4
     ZEILE4_OFF;
 3de:	57 98       	cbi	0x0a, 7	; 10
     SPALTE1_ON;
 3e0:	5e 9a       	sbi	0x0b, 6	; 11
     SPALTE2_OFF;
 3e2:	5d 98       	cbi	0x0b, 5	; 11
     SPALTE3_OFF;
 3e4:	5c 98       	cbi	0x0b, 4	; 11
     SPALTE4_OFF;
 3e6:	5b 98       	cbi	0x0b, 3	; 11
     SPALTE5_OFF;
 3e8:	5a 98       	cbi	0x0b, 2	; 11
     break;
 3ea:	08 95       	ret
     case 7:
     ZEILE1_OFF;        // LED7 AN
 3ec:	22 98       	cbi	0x04, 2	; 4
     ZEILE2_ON;
 3ee:	21 9a       	sbi	0x04, 1	; 4
     ZEILE3_OFF;
 3f0:	20 98       	cbi	0x04, 0	; 4
     ZEILE4_OFF;
 3f2:	57 98       	cbi	0x0a, 7	; 10
     SPALTE1_OFF;
 3f4:	5e 98       	cbi	0x0b, 6	; 11
     SPALTE2_ON;
 3f6:	5d 9a       	sbi	0x0b, 5	; 11
     SPALTE3_OFF;
 3f8:	5c 98       	cbi	0x0b, 4	; 11
     SPALTE4_OFF;
 3fa:	5b 98       	cbi	0x0b, 3	; 11
     SPALTE5_OFF;
 3fc:	5a 98       	cbi	0x0b, 2	; 11
     break;
 3fe:	08 95       	ret
     case 8:
     ZEILE1_OFF;        // LED8 AN
 400:	22 98       	cbi	0x04, 2	; 4
     ZEILE2_ON;
 402:	21 9a       	sbi	0x04, 1	; 4
     ZEILE3_OFF;
 404:	20 98       	cbi	0x04, 0	; 4
     ZEILE4_OFF;
 406:	57 98       	cbi	0x0a, 7	; 10
     SPALTE1_OFF;
 408:	5e 98       	cbi	0x0b, 6	; 11
     SPALTE2_OFF;
 40a:	5d 98       	cbi	0x0b, 5	; 11
     SPALTE3_ON;
 40c:	5c 9a       	sbi	0x0b, 4	; 11
     SPALTE4_OFF;
 40e:	5b 98       	cbi	0x0b, 3	; 11
     SPALTE5_OFF;
 410:	5a 98       	cbi	0x0b, 2	; 11
     break;
 412:	08 95       	ret
     case 9:
     ZEILE1_OFF;        // LED9 AN
 414:	22 98       	cbi	0x04, 2	; 4
     ZEILE2_ON;
 416:	21 9a       	sbi	0x04, 1	; 4
     ZEILE3_OFF;
 418:	20 98       	cbi	0x04, 0	; 4
     ZEILE4_OFF;
 41a:	57 98       	cbi	0x0a, 7	; 10
     SPALTE1_OFF;
 41c:	5e 98       	cbi	0x0b, 6	; 11
     SPALTE2_OFF;
 41e:	5d 98       	cbi	0x0b, 5	; 11
     SPALTE3_OFF;
 420:	5c 98       	cbi	0x0b, 4	; 11
     SPALTE4_ON;
 422:	5b 9a       	sbi	0x0b, 3	; 11
     SPALTE5_OFF;
 424:	5a 98       	cbi	0x0b, 2	; 11
     break;
 426:	08 95       	ret
     case 10:
     ZEILE1_OFF;        // LED10 AN
 428:	22 98       	cbi	0x04, 2	; 4
     ZEILE2_ON;
 42a:	21 9a       	sbi	0x04, 1	; 4
     ZEILE3_OFF;
 42c:	20 98       	cbi	0x04, 0	; 4
     ZEILE4_OFF;
 42e:	57 98       	cbi	0x0a, 7	; 10
     SPALTE1_OFF;
 430:	5e 98       	cbi	0x0b, 6	; 11
     SPALTE2_OFF;
 432:	5d 98       	cbi	0x0b, 5	; 11
     SPALTE3_OFF;
 434:	5c 98       	cbi	0x0b, 4	; 11
     SPALTE4_OFF;
 436:	5b 98       	cbi	0x0b, 3	; 11
     SPALTE5_ON;
 438:	5a 9a       	sbi	0x0b, 2	; 11
     break;
 43a:	08 95       	ret
     case 11:
     ZEILE1_OFF;        // LED11 AN
 43c:	22 98       	cbi	0x04, 2	; 4
     ZEILE2_OFF;
 43e:	21 98       	cbi	0x04, 1	; 4
     ZEILE3_ON;
 440:	20 9a       	sbi	0x04, 0	; 4
     ZEILE4_OFF;
 442:	57 98       	cbi	0x0a, 7	; 10
     SPALTE1_ON;
 444:	5e 9a       	sbi	0x0b, 6	; 11
     SPALTE2_OFF;
 446:	5d 98       	cbi	0x0b, 5	; 11
     SPALTE3_OFF;
 448:	5c 98       	cbi	0x0b, 4	; 11
     SPALTE4_OFF;
 44a:	5b 98       	cbi	0x0b, 3	; 11
     SPALTE5_OFF;
 44c:	5a 98       	cbi	0x0b, 2	; 11
     break;
 44e:	08 95       	ret
     case 12:
     ZEILE1_OFF;        // LED12 AN
 450:	22 98       	cbi	0x04, 2	; 4
     ZEILE2_OFF;
 452:	21 98       	cbi	0x04, 1	; 4
     ZEILE3_ON;
 454:	20 9a       	sbi	0x04, 0	; 4
     ZEILE4_OFF;
 456:	57 98       	cbi	0x0a, 7	; 10
     SPALTE1_OFF;
 458:	5e 98       	cbi	0x0b, 6	; 11
     SPALTE2_ON;
 45a:	5d 9a       	sbi	0x0b, 5	; 11
     SPALTE3_OFF;
 45c:	5c 98       	cbi	0x0b, 4	; 11
     SPALTE4_OFF;
 45e:	5b 98       	cbi	0x0b, 3	; 11
     SPALTE5_OFF;
 460:	5a 98       	cbi	0x0b, 2	; 11
     break;
 462:	08 95       	ret
     case 13:
     ZEILE1_OFF;        // LED13 AN
 464:	22 98       	cbi	0x04, 2	; 4
     ZEILE2_OFF;
 466:	21 98       	cbi	0x04, 1	; 4
     ZEILE3_ON;
 468:	20 9a       	sbi	0x04, 0	; 4
     ZEILE4_OFF;
 46a:	57 98       	cbi	0x0a, 7	; 10
     SPALTE1_OFF;
 46c:	5e 98       	cbi	0x0b, 6	; 11
     SPALTE2_OFF;
 46e:	5d 98       	cbi	0x0b, 5	; 11
     SPALTE3_ON;
 470:	5c 9a       	sbi	0x0b, 4	; 11
     SPALTE4_OFF;
 472:	5b 98       	cbi	0x0b, 3	; 11
     SPALTE5_OFF;
 474:	5a 98       	cbi	0x0b, 2	; 11
     break;
 476:	08 95       	ret
     case 14:
     ZEILE1_OFF;        // LED14 AN
 478:	22 98       	cbi	0x04, 2	; 4
     ZEILE2_OFF;
 47a:	21 98       	cbi	0x04, 1	; 4
     ZEILE3_ON;
 47c:	20 9a       	sbi	0x04, 0	; 4
     ZEILE4_OFF;
 47e:	57 98       	cbi	0x0a, 7	; 10
     SPALTE1_OFF;
 480:	5e 98       	cbi	0x0b, 6	; 11
     SPALTE2_OFF;
 482:	5d 98       	cbi	0x0b, 5	; 11
     SPALTE3_OFF;
 484:	5c 98       	cbi	0x0b, 4	; 11
     SPALTE4_ON;
 486:	5b 9a       	sbi	0x0b, 3	; 11
     SPALTE5_OFF;
 488:	5a 98       	cbi	0x0b, 2	; 11
     break;
 48a:	08 95       	ret
     case 15:
     ZEILE1_OFF;        // LED15 AN
 48c:	22 98       	cbi	0x04, 2	; 4
     ZEILE2_OFF;
 48e:	21 98       	cbi	0x04, 1	; 4
     ZEILE3_ON;
 490:	20 9a       	sbi	0x04, 0	; 4
     ZEILE4_OFF;
 492:	57 98       	cbi	0x0a, 7	; 10
     SPALTE1_OFF;
 494:	5e 98       	cbi	0x0b, 6	; 11
     SPALTE2_OFF;
 496:	5d 98       	cbi	0x0b, 5	; 11
     SPALTE3_OFF;
 498:	5c 98       	cbi	0x0b, 4	; 11
     SPALTE4_OFF;
 49a:	5b 98       	cbi	0x0b, 3	; 11
     SPALTE5_ON;
 49c:	5a 9a       	sbi	0x0b, 2	; 11
     break;
 49e:	08 95       	ret
     case 16:
     ZEILE1_OFF;        // LED16 AN
 4a0:	22 98       	cbi	0x04, 2	; 4
     ZEILE2_OFF;
 4a2:	21 98       	cbi	0x04, 1	; 4
     ZEILE3_OFF;
 4a4:	20 98       	cbi	0x04, 0	; 4
     ZEILE4_ON;
 4a6:	57 9a       	sbi	0x0a, 7	; 10
     SPALTE1_ON;
 4a8:	5e 9a       	sbi	0x0b, 6	; 11
     SPALTE2_OFF;
 4aa:	5d 98       	cbi	0x0b, 5	; 11
     SPALTE3_OFF;
 4ac:	5c 98       	cbi	0x0b, 4	; 11
     SPALTE4_OFF;
 4ae:	5b 98       	cbi	0x0b, 3	; 11
     SPALTE5_OFF;
 4b0:	5a 98       	cbi	0x0b, 2	; 11
     break;
 4b2:	08 95       	ret
     case 17:
     ZEILE1_OFF;        // LED17 AN
 4b4:	22 98       	cbi	0x04, 2	; 4
     ZEILE2_OFF;
 4b6:	21 98       	cbi	0x04, 1	; 4
     ZEILE3_OFF;
 4b8:	20 98       	cbi	0x04, 0	; 4
     ZEILE4_ON;
 4ba:	57 9a       	sbi	0x0a, 7	; 10
     SPALTE1_OFF;
 4bc:	5e 98       	cbi	0x0b, 6	; 11
     SPALTE2_ON;
 4be:	5d 9a       	sbi	0x0b, 5	; 11
     SPALTE3_OFF;
 4c0:	5c 98       	cbi	0x0b, 4	; 11
     SPALTE4_OFF;
 4c2:	5b 98       	cbi	0x0b, 3	; 11
     SPALTE5_OFF;
 4c4:	5a 98       	cbi	0x0b, 2	; 11
     break;
 4c6:	08 95       	ret
     case 18:
     ZEILE1_OFF;        // LED18 AN
 4c8:	22 98       	cbi	0x04, 2	; 4
     ZEILE2_OFF;
 4ca:	21 98       	cbi	0x04, 1	; 4
     ZEILE3_OFF;
 4cc:	20 98       	cbi	0x04, 0	; 4
     ZEILE4_ON;
 4ce:	57 9a       	sbi	0x0a, 7	; 10
     SPALTE1_OFF;
 4d0:	5e 98       	cbi	0x0b, 6	; 11
     SPALTE2_OFF;
 4d2:	5d 98       	cbi	0x0b, 5	; 11
     SPALTE3_ON;
 4d4:	5c 9a       	sbi	0x0b, 4	; 11
     SPALTE4_OFF;
 4d6:	5b 98       	cbi	0x0b, 3	; 11
     SPALTE5_OFF;
 4d8:	5a 98       	cbi	0x0b, 2	; 11
     break;
 4da:	08 95       	ret
     case 19:
     ZEILE1_OFF;        // LED19 AN
 4dc:	22 98       	cbi	0x04, 2	; 4
     ZEILE2_OFF;
 4de:	21 98       	cbi	0x04, 1	; 4
     ZEILE3_OFF;
 4e0:	20 98       	cbi	0x04, 0	; 4
     ZEILE4_ON;
 4e2:	57 9a       	sbi	0x0a, 7	; 10
     SPALTE1_OFF;
 4e4:	5e 98       	cbi	0x0b, 6	; 11
     SPALTE2_OFF;
 4e6:	5d 98       	cbi	0x0b, 5	; 11
     SPALTE3_OFF;
 4e8:	5c 98       	cbi	0x0b, 4	; 11
     SPALTE4_ON;
 4ea:	5b 9a       	sbi	0x0b, 3	; 11
     SPALTE5_OFF;
 4ec:	5a 98       	cbi	0x0b, 2	; 11
     break;
 4ee:	08 95       	ret
     default:
     ZEILE1_OFF;        // LEDs AUS
 4f0:	22 98       	cbi	0x04, 2	; 4
     ZEILE2_OFF;
 4f2:	21 98       	cbi	0x04, 1	; 4
     ZEILE3_OFF;
 4f4:	20 98       	cbi	0x04, 0	; 4
     ZEILE4_OFF;
 4f6:	57 98       	cbi	0x0a, 7	; 10
     SPALTE1_OFF;
 4f8:	5e 98       	cbi	0x0b, 6	; 11
     SPALTE2_OFF;
 4fa:	5d 98       	cbi	0x0b, 5	; 11
     SPALTE3_OFF;
 4fc:	5c 98       	cbi	0x0b, 4	; 11
     SPALTE4_OFF;
 4fe:	5b 98       	cbi	0x0b, 3	; 11
     SPALTE5_OFF;
 500:	5a 98       	cbi	0x0b, 2	; 11
     break;
    }

}
 502:	08 95       	ret

00000504 <PORTs_init>:
Bei Init werden die PORTS PB0 bis PB2 als Ausgang gesetzt
und die PORTS PB3 bis PB7 als Ausgang
PULLUP Widerstaende zur Abfrage der Jumper Stellung werden im Programm gesetzt.

*/
    DDRB = 0b00000111;
 504:	87 e0       	ldi	r24, 0x07	; 7
 506:	84 b9       	out	0x04, r24	; 4
    PORTD =0b00000000;
 508:	1b b8       	out	0x0b, r1	; 11
PC6 = RESET
PC7 = NC
Alle Ports auf Eingang, bis auf PORT PC5 AUSGANG fuer DEBUG Ausgabe 
PULLUP Widerstand vom PORT PC2,PC4 aktive
*/
    DDRC =  0b00100000;
 50a:	80 e2       	ldi	r24, 0x20	; 32
 50c:	87 b9       	out	0x07, r24	; 7
    PORTC = 0b00010100;
 50e:	84 e1       	ldi	r24, 0x14	; 20
 510:	88 b9       	out	0x08, r24	; 8
Port PD2 bis PD7 auf Ausgang



*/
    DDRD =  0b01111100;
 512:	8c e7       	ldi	r24, 0x7C	; 124
 514:	8a b9       	out	0x0a, r24	; 10
    PORTD = 0b00000000;
 516:	1b b8       	out	0x0b, r1	; 11
}
 518:	08 95       	ret

0000051a <TIMER_init>:

    /*
     * Timer 0: LED-Multiplexing, im Überlauf-Interrupt
     */
#if F_CPU < 10000000
    TCCR0B = _BV(CS00); // Vorteiler 1, bei 3,68 MHz => 69us => 14kHz
 51a:	81 e0       	ldi	r24, 0x01	; 1
 51c:	85 bd       	out	0x25, r24	; 37
#else
    TCCR0B = _BV(CS01) | _BV(CS00); // Vorteiler 64, bei 12 MHz => 730 Hz
#endif
    TIMSK0 = _BV(TOIE0); // Timer0 Overflow Interrupt Enable
 51e:	80 93 6e 00 	sts	0x006E, r24

    /*
     * Timer 2: allgemeine Zeitablaufsteuerung
     */
#if F_CPU < 10000000
    TCCR2B = _BV(CS22) | _BV(CS21); // Teiler  256, bei 3,68 MHz 52 Hz Rate
 522:	96 e0       	ldi	r25, 0x06	; 6
 524:	90 93 b1 00 	sts	0x00B1, r25
#else
    TCCR2B = _BV(CS22) | _BV(CS21) | _BV(CS20); // Teiler 1024, bei 12 MHz 45 Hz Rate
#endif
    TIMSK2 = _BV(TOIE2); // Timer2 Overflow Interrupt Enable
 528:	80 93 70 00 	sts	0x0070, r24

/************************ Analog Digital Wandler Singel **********************/
    // Interne Referenz 1,1 V; Kanal 8 (interner Temperatursensor)
    ADMUX = _BV(REFS1) | _BV(REFS0) | _BV(MUX3);
 52c:	88 ec       	ldi	r24, 0xC8	; 200
 52e:	80 93 7c 00 	sts	0x007C, r24
#if F_CPU < 10000000
    // ADC enable, Vorteiler 32 => 115 kHz Takt bei 3,68 MHz
	ADCSRA = _BV(ADEN) | _BV(ADPS2) | _BV(ADPS0);
 532:	85 e8       	ldi	r24, 0x85	; 133
 534:	80 93 7a 00 	sts	0x007A, r24
#else
    // ADC enable, Vorteiler 64 => 187 kHz bei 12 MHz
    ADCSRA = _BV(ADEN) | _BV(ADPS2) | _BV(ADPS1);
#endif
}
 538:	08 95       	ret

0000053a <main>:

int main(void)
{
    uint8_t  templ = 0,temph = 0;
    uint16_t temperaturdaten = 0;
    LED_HELLIGKEIT = 0;
 53a:	10 92 96 01 	sts	0x0196, r1
	drehcounter = 0;
 53e:	10 92 c1 01 	sts	0x01C1, r1
    PORTs_init();                       // Init der Ein und Ausgabeports
 542:	0e 94 82 02 	call	0x504	; 0x504 <PORTs_init>
    TIMER_init();                       // Timer Init
 546:	0e 94 8d 02 	call	0x51a	; 0x51a <TIMER_init>
#if UART_DEBUG == 1
	UART_init();                        // INIT 485
 54a:	0e 94 c6 04 	call	0x98c	; 0x98c <UART_init>
#endif
    sei();                              // INTERRUPTS GLOBAL AN
 54e:	78 94       	sei
	LED_TASK[1][0]=1;					// LED 1 AN nach INIT
 550:	81 e0       	ldi	r24, 0x01	; 1
 552:	80 93 99 01 	sts	0x0199, r24
            LED_TASK[step][0]=1;

    }
    */
#if UART_DEBUG == 1
	putstring("Tempanzeige und Wuerfel Ver 0.4");         // Ausgabe Versionstext Text
 556:	84 e0       	ldi	r24, 0x04	; 4
 558:	91 e0       	ldi	r25, 0x01	; 1
 55a:	0e 94 e1 04 	call	0x9c2	; 0x9c2 <putstring>


int main(void)
{
    uint8_t  templ = 0,temph = 0;
    uint16_t temperaturdaten = 0;
 55e:	10 e0       	ldi	r17, 0x00	; 0
 560:	00 e0       	ldi	r16, 0x00	; 0
 562:	0f 2e       	mov	r0, r31
 564:	ff eb       	ldi	r31, 0xBF	; 191
 566:	ef 2e       	mov	r14, r31
 568:	f1 e0       	ldi	r31, 0x01	; 1
 56a:	ff 2e       	mov	r15, r31
 56c:	f0 2d       	mov	r31, r0
 startet den Analogdigitalwandler
 zum Auslesen des int Temp Sensor                                                                    
******************************************************************************/
         if (counter == 20)
              {
              sbi(6,ADCSRA);
 56e:	0f 2e       	mov	r0, r31
 570:	fa e7       	ldi	r31, 0x7A	; 122
 572:	cf 2e       	mov	r12, r31
 574:	d1 2c       	mov	r13, r1
 576:	f0 2d       	mov	r31, r0
/******************************************************************************
Auslesen der Temperaturdaten aus den AD Wandler
******************************************************************************/
         if (counter == 70 )
              {
	          templ = ADCL;
 578:	0f 2e       	mov	r0, r31
 57a:	f8 e7       	ldi	r31, 0x78	; 120
 57c:	8f 2e       	mov	r8, r31
 57e:	91 2c       	mov	r9, r1
 580:	f0 2d       	mov	r31, r0
	          temph = ADCH;
 582:	0f 2e       	mov	r0, r31
 584:	f9 e7       	ldi	r31, 0x79	; 121
 586:	6f 2e       	mov	r6, r31
 588:	71 2c       	mov	r7, r1
 58a:	f0 2d       	mov	r31, r0
 58c:	cd ea       	ldi	r28, 0xAD	; 173
 58e:	d1 e0       	ldi	r29, 0x01	; 1
					   {
					   LED_TASK[1][0]=1;
					   } 
					else
					   {
					   LED_TASK[1][0]=0;   
 590:	0f 2e       	mov	r0, r31
 592:	f7 e9       	ldi	r31, 0x97	; 151
 594:	af 2e       	mov	r10, r31
 596:	f1 e0       	ldi	r31, 0x01	; 1
 598:	bf 2e       	mov	r11, r31
 59a:	f0 2d       	mov	r31, r0
			    } 
			else
			   { //PLAYER 1   
				if (player1 > 10)
				   {
					for (uint8_t step = 1; step <= (player1 -10) ; step++)
 59c:	44 24       	eor	r4, r4
 59e:	43 94       	inc	r4
 5a0:	51 2c       	mov	r5, r1
 5a2:	b5 c0       	rjmp	.+362    	; 0x70e <main+0x1d4>

                                                                     
******************************************************************************/
         if (counter == 10)
              {
              if( !qbi(SW_WUERFEL,SW_PORT) )
 5a4:	34 99       	sbic	0x06, 4	; 6
 5a6:	ba c0       	rjmp	.+372    	; 0x71c <main+0x1e2>
                {
			    switch(mode)
 5a8:	80 91 c2 01 	lds	r24, 0x01C2
 5ac:	83 30       	cpi	r24, 0x03	; 3
 5ae:	f1 f1       	breq	.+124    	; 0x62c <main+0xf2>
 5b0:	e0 f4       	brcc	.+56     	; 0x5ea <main+0xb0>
 5b2:	81 30       	cpi	r24, 0x01	; 1
 5b4:	61 f1       	breq	.+88     	; 0x60e <main+0xd4>
 5b6:	82 30       	cpi	r24, 0x02	; 2
 5b8:	49 f4       	brne	.+18     	; 0x5cc <main+0x92>
				    cbi(WUERFEL_7,FLAGS);			// Wuerfel 1 - 6 
				    multi_player(0);                // Singelplayer
				    break;
				    case 2:	                        // Wuerfel
				    sbi(TEMP_OFF,FLAGS);			// Temperaturanzeige AUS
				    sbi(WUERFEL_7,FLAGS);			// Wuerfel 1 - 7
 5ba:	80 91 c5 01 	lds	r24, 0x01C5
 5be:	86 60       	ori	r24, 0x06	; 6
 5c0:	80 93 c5 01 	sts	0x01C5, r24
				    multi_player(0);                // Singelplayer
 5c4:	80 e0       	ldi	r24, 0x00	; 0
 5c6:	0e 94 6d 00 	call	0xda	; 0xda <multi_player>
				    break;
 5ca:	2a c0       	rjmp	.+84     	; 0x620 <main+0xe6>
******************************************************************************/
         if (counter == 10)
              {
              if( !qbi(SW_WUERFEL,SW_PORT) )
                {
			    switch(mode)
 5cc:	81 11       	cpse	r24, r1
 5ce:	28 c0       	rjmp	.+80     	; 0x620 <main+0xe6>
			    {
				    case 0:                         // Temperatur Anzeige
				    cbi(TEMP_OFF,FLAGS);			// Temperaturanzeige AN
				    cbi(TEMPISOFF,FLAGS);			// Ruecksetzen TEMPIS OFF
 5d0:	80 91 c5 01 	lds	r24, 0x01C5
 5d4:	83 7f       	andi	r24, 0xF3	; 243
 5d6:	80 93 c5 01 	sts	0x01C5, r24
 5da:	e9 e9       	ldi	r30, 0x99	; 153
 5dc:	f1 e0       	ldi	r31, 0x01	; 1
				    for (uint8_t step = 1; step <= 19 ; step++)
				    {
					    LED_TASK[step][0]=0;       // LED`s aus
 5de:	10 82       	st	Z, r1
 5e0:	32 96       	adiw	r30, 0x02	; 2
			    switch(mode)
			    {
				    case 0:                         // Temperatur Anzeige
				    cbi(TEMP_OFF,FLAGS);			// Temperaturanzeige AN
				    cbi(TEMPISOFF,FLAGS);			// Ruecksetzen TEMPIS OFF
				    for (uint8_t step = 1; step <= 19 ; step++)
 5e2:	ee 16       	cp	r14, r30
 5e4:	ff 06       	cpc	r15, r31
 5e6:	d9 f7       	brne	.-10     	; 0x5de <main+0xa4>
 5e8:	1b c0       	rjmp	.+54     	; 0x620 <main+0xe6>
******************************************************************************/
         if (counter == 10)
              {
              if( !qbi(SW_WUERFEL,SW_PORT) )
                {
			    switch(mode)
 5ea:	84 30       	cpi	r24, 0x04	; 4
 5ec:	d1 f1       	breq	.+116    	; 0x662 <main+0x128>
 5ee:	86 30       	cpi	r24, 0x06	; 6
 5f0:	b9 f4       	brne	.+46     	; 0x620 <main+0xe6>
				    // Noch nicht implementiert
				    break;
				    case 6:
				    // Alle LED`s an
				    sbi(TEMP_OFF,FLAGS);			// Temperaturanzeige AUS
				    sbi(TEMPISOFF,FLAGS);
 5f2:	80 91 c5 01 	lds	r24, 0x01C5
 5f6:	8c 60       	ori	r24, 0x0C	; 12
 5f8:	80 93 c5 01 	sts	0x01C5, r24
 5fc:	e9 e9       	ldi	r30, 0x99	; 153
 5fe:	f1 e0       	ldi	r31, 0x01	; 1
				    for (uint8_t step = 1; step <= 19 ; step++)
				        {
					    LED_TASK[step][0]=1;
 600:	81 e0       	ldi	r24, 0x01	; 1
 602:	80 83       	st	Z, r24
 604:	32 96       	adiw	r30, 0x02	; 2
				    break;
				    case 6:
				    // Alle LED`s an
				    sbi(TEMP_OFF,FLAGS);			// Temperaturanzeige AUS
				    sbi(TEMPISOFF,FLAGS);
				    for (uint8_t step = 1; step <= 19 ; step++)
 606:	ee 16       	cp	r14, r30
 608:	ff 06       	cpc	r15, r31
 60a:	d9 f7       	brne	.-10     	; 0x602 <main+0xc8>
 60c:	09 c0       	rjmp	.+18     	; 0x620 <main+0xe6>
					    LED_TASK[step][0]=0;       // LED`s aus
				    }
				    break;
				    case 1:	                        // Wuerfel
				    sbi(TEMP_OFF,FLAGS);			// Temperaturanzeige AUS
				    cbi(WUERFEL_7,FLAGS);			// Wuerfel 1 - 6 
 60e:	80 91 c5 01 	lds	r24, 0x01C5
 612:	8d 7f       	andi	r24, 0xFD	; 253
 614:	84 60       	ori	r24, 0x04	; 4
 616:	80 93 c5 01 	sts	0x01C5, r24
				    multi_player(0);                // Singelplayer
 61a:	80 e0       	ldi	r24, 0x00	; 0
 61c:	0e 94 6d 00 	call	0xda	; 0xda <multi_player>
				        {
					    LED_TASK[step][0]=1;
				        }
				    break;
			    }
                 counter++;
 620:	80 91 c3 01 	lds	r24, 0x01C3
 624:	8f 5f       	subi	r24, 0xFF	; 255
 626:	80 93 c3 01 	sts	0x01C3, r24
 62a:	78 c0       	rjmp	.+240    	; 0x71c <main+0x1e2>
				    sbi(TEMP_OFF,FLAGS);			// Temperaturanzeige AUS
				    sbi(WUERFEL_7,FLAGS);			// Wuerfel 1 - 7
				    multi_player(0);                // Singelplayer
				    break;
				    case 3:	                        // Wuerfel 
				    sbi(TEMP_OFF,FLAGS);			// Temperaturanzeige AUS
 62c:	90 91 c5 01 	lds	r25, 0x01C5
				    cbi(WUERFEL_7,FLAGS);			// Wuerfel 1 - 6
 630:	89 2f       	mov	r24, r25
 632:	8d 7f       	andi	r24, 0xFD	; 253
 634:	84 60       	ori	r24, 0x04	; 4
 636:	80 93 c5 01 	sts	0x01C5, r24
				    if(qbi(PLAYER,FLAGS))
 63a:	94 ff       	sbrs	r25, 4
 63c:	09 c0       	rjmp	.+18     	; 0x650 <main+0x116>
				        {
					    multi_player(1);            // Player1
 63e:	81 e0       	ldi	r24, 0x01	; 1
 640:	0e 94 6d 00 	call	0xda	; 0xda <multi_player>
					    cbi(PLAYER,FLAGS);
 644:	80 91 c5 01 	lds	r24, 0x01C5
 648:	8f 7e       	andi	r24, 0xEF	; 239
 64a:	80 93 c5 01 	sts	0x01C5, r24
 64e:	e8 cf       	rjmp	.-48     	; 0x620 <main+0xe6>
				        }
				    else
				        {
					    multi_player(2);            // Player	2
 650:	82 e0       	ldi	r24, 0x02	; 2
 652:	0e 94 6d 00 	call	0xda	; 0xda <multi_player>
					    sbi(PLAYER,FLAGS);
 656:	80 91 c5 01 	lds	r24, 0x01C5
 65a:	80 61       	ori	r24, 0x10	; 16
 65c:	80 93 c5 01 	sts	0x01C5, r24
 660:	df cf       	rjmp	.-66     	; 0x620 <main+0xe6>
				        }
				    break;
				    case 4:	                        // Wuerfel
				    sbi(TEMP_OFF,FLAGS);			// Temperaturanzeige AUS
 662:	80 91 c5 01 	lds	r24, 0x01C5
				    sbi(WUERFEL_7,FLAGS);			// Wuerfel 1 - 7
 666:	98 2f       	mov	r25, r24
 668:	96 60       	ori	r25, 0x06	; 6
 66a:	90 93 c5 01 	sts	0x01C5, r25
				    if(qbi(PLAYER,FLAGS))
 66e:	84 ff       	sbrs	r24, 4
 670:	09 c0       	rjmp	.+18     	; 0x684 <main+0x14a>
				        {
					    multi_player(1);            // Player1
 672:	81 e0       	ldi	r24, 0x01	; 1
 674:	0e 94 6d 00 	call	0xda	; 0xda <multi_player>
					    cbi(PLAYER,FLAGS);
 678:	80 91 c5 01 	lds	r24, 0x01C5
 67c:	8f 7e       	andi	r24, 0xEF	; 239
 67e:	80 93 c5 01 	sts	0x01C5, r24
 682:	ce cf       	rjmp	.-100    	; 0x620 <main+0xe6>
				        }
				    else
				        {
					    multi_player(2);            // Player2
 684:	82 e0       	ldi	r24, 0x02	; 2
 686:	0e 94 6d 00 	call	0xda	; 0xda <multi_player>
					    sbi(PLAYER,FLAGS); //TEST
 68a:	80 91 c5 01 	lds	r24, 0x01C5
 68e:	80 61       	ori	r24, 0x10	; 16
 690:	80 93 c5 01 	sts	0x01C5, r24
 694:	c5 cf       	rjmp	.-118    	; 0x620 <main+0xe6>
 startet den Analogdigitalwandler
 zum Auslesen des int Temp Sensor                                                                    
******************************************************************************/
         if (counter == 20)
              {
              sbi(6,ADCSRA);
 696:	f6 01       	movw	r30, r12
 698:	80 81       	ld	r24, Z
 69a:	80 64       	ori	r24, 0x40	; 64
 69c:	80 83       	st	Z, r24
              counter++;
 69e:	80 91 c3 01 	lds	r24, 0x01C3
 6a2:	8f 5f       	subi	r24, 0xFF	; 255
 6a4:	80 93 c3 01 	sts	0x01C3, r24
 6a8:	3e c0       	rjmp	.+124    	; 0x726 <main+0x1ec>
/******************************************************************************
Auslesen der Temperaturdaten aus den AD Wandler
******************************************************************************/
         if (counter == 70 )
              {
	          templ = ADCL;
 6aa:	f4 01       	movw	r30, r8
 6ac:	00 81       	ld	r16, Z
	          temph = ADCH;
 6ae:	f3 01       	movw	r30, r6
 6b0:	80 81       	ld	r24, Z
	          temperaturdaten = HILO(temph,templ);
 6b2:	18 2f       	mov	r17, r24
              counter++;
 6b4:	80 91 c3 01 	lds	r24, 0x01C3
 6b8:	8f 5f       	subi	r24, 0xFF	; 255
 6ba:	80 93 c3 01 	sts	0x01C3, r24
 6be:	38 c0       	rjmp	.+112    	; 0x730 <main+0x1f6>
                    }   
			   }
			}
		 else
			{
		 if (counter == 200)
 6c0:	80 91 c3 01 	lds	r24, 0x01C3
 6c4:	88 3c       	cpi	r24, 0xC8	; 200
 6c6:	09 f4       	brne	.+2      	; 0x6ca <main+0x190>
 6c8:	44 c0       	rjmp	.+136    	; 0x752 <main+0x218>
/******************************************************************************
Im Multiplayer Mode
Hier wird nach dem Wuerfeln die Anzeige des aktuellen Spielstandes aktualisiert
Ist der Spielstand kleiner 10 blinkt die erste LED der Anzeige
******************************************************************************/	
         if ( (drehaktiv == 0) & (qbi(TEMPISOFF,FLAGS)) & (mode > 2) )
 6ca:	90 91 c8 01 	lds	r25, 0x01C8
 6ce:	20 91 c5 01 	lds	r18, 0x01C5
 6d2:	30 91 c2 01 	lds	r19, 0x01C2
 6d6:	81 e0       	ldi	r24, 0x01	; 1
 6d8:	91 11       	cpse	r25, r1
 6da:	80 e0       	ldi	r24, 0x00	; 0
 6dc:	91 e0       	ldi	r25, 0x01	; 1
 6de:	33 30       	cpi	r19, 0x03	; 3
 6e0:	08 f4       	brcc	.+2      	; 0x6e4 <main+0x1aa>
 6e2:	90 e0       	ldi	r25, 0x00	; 0
 6e4:	89 23       	and	r24, r25
 6e6:	79 f0       	breq	.+30     	; 0x706 <main+0x1cc>
 6e8:	23 ff       	sbrs	r18, 3
 6ea:	0d c0       	rjmp	.+26     	; 0x706 <main+0x1cc>
			{			
			if (qbi(PLAYER,FLAGS))
 6ec:	24 ff       	sbrs	r18, 4
 6ee:	58 c0       	rjmp	.+176    	; 0x7a0 <main+0x266>
			    { // PLAYER 2
				 if (player2 > 10)
 6f0:	80 91 c4 01 	lds	r24, 0x01C4
 6f4:	8b 30       	cpi	r24, 0x0B	; 11
 6f6:	c0 f5       	brcc	.+112    	; 0x768 <main+0x22e>
						LED_TASK[step][0]=1;
					    }	 
					 }
				 else
				     {
					 if (qbi(4,counter))
 6f8:	80 91 c3 01 	lds	r24, 0x01C3
 6fc:	84 ff       	sbrs	r24, 4
 6fe:	4d c0       	rjmp	.+154    	; 0x79a <main+0x260>
					     {
						 LED_TASK[1][0]=1;
 700:	81 e0       	ldi	r24, 0x01	; 1
 702:	f5 01       	movw	r30, r10
 704:	82 83       	std	Z+2, r24	; 0x02
Wenn dreaktiv gesetzt ist startet der Wuerfel, 
drehaktiv bestimmt die Anzahl der Umlaufe
Uebergabe der Geschwindigkeit des Wuerfels
******************************************************************************/		 
		 
		 if (drehaktiv)
 706:	80 91 c8 01 	lds	r24, 0x01C8
 70a:	81 11       	cpse	r24, r1
 70c:	72 c0       	rjmp	.+228    	; 0x7f2 <main+0x2b8>
#endif
	
    while(1)
    {
#if UART_DEBUG == 1
        uart_action();
 70e:	0e 94 6c 05 	call	0xad8	; 0xad8 <uart_action>
/*****************************************************************************
 Abfrage Taster zum starten des Wuerfels und Auswertung der Jumper

                                                                     
******************************************************************************/
         if (counter == 10)
 712:	80 91 c3 01 	lds	r24, 0x01C3
 716:	8a 30       	cpi	r24, 0x0A	; 10
 718:	09 f4       	brne	.+2      	; 0x71c <main+0x1e2>
 71a:	44 cf       	rjmp	.-376    	; 0x5a4 <main+0x6a>

/*****************************************************************************
 startet den Analogdigitalwandler
 zum Auslesen des int Temp Sensor                                                                    
******************************************************************************/
         if (counter == 20)
 71c:	80 91 c3 01 	lds	r24, 0x01C3
 720:	84 31       	cpi	r24, 0x14	; 20
 722:	09 f4       	brne	.+2      	; 0x726 <main+0x1ec>
 724:	b8 cf       	rjmp	.-144    	; 0x696 <main+0x15c>
              }

/******************************************************************************
Auslesen der Temperaturdaten aus den AD Wandler
******************************************************************************/
         if (counter == 70 )
 726:	80 91 c3 01 	lds	r24, 0x01C3
 72a:	86 34       	cpi	r24, 0x46	; 70
 72c:	09 f4       	brne	.+2      	; 0x730 <main+0x1f6>
 72e:	bd cf       	rjmp	.-134    	; 0x6aa <main+0x170>
/******************************************************************************
Ausgabe der Temperaturdaten auf das LED Band
Ist Temp OFF gesetzt werden die TEMP LEDS geloescht 
FLAG TEMPISOFF wird gesetzt damit das LED Temperaturband nur einmal ruckgesetzt wird                                                                 
******************************************************************************/
         if ( qbi(TEMP_OFF,FLAGS) )
 730:	80 91 c5 01 	lds	r24, 0x01C5
 734:	82 ff       	sbrs	r24, 2
 736:	c4 cf       	rjmp	.-120    	; 0x6c0 <main+0x186>
			{
			if (!qbi(TEMPISOFF,FLAGS))
 738:	83 fd       	sbrc	r24, 3
 73a:	c7 cf       	rjmp	.-114    	; 0x6ca <main+0x190>
			   {
				sbi(TEMPISOFF,FLAGS);   
 73c:	88 60       	ori	r24, 0x08	; 8
 73e:	80 93 c5 01 	sts	0x01C5, r24
 742:	e7 e9       	ldi	r30, 0x97	; 151
 744:	f1 e0       	ldi	r31, 0x01	; 1
				for (uint8_t step = 0; step <= 10 ; step++)
                    {
					LED_TASK[step][0]=0;
 746:	10 82       	st	Z, r1
 748:	32 96       	adiw	r30, 0x02	; 2
         if ( qbi(TEMP_OFF,FLAGS) )
			{
			if (!qbi(TEMPISOFF,FLAGS))
			   {
				sbi(TEMPISOFF,FLAGS);   
				for (uint8_t step = 0; step <= 10 ; step++)
 74a:	ce 17       	cp	r28, r30
 74c:	df 07       	cpc	r29, r31
 74e:	d9 f7       	brne	.-10     	; 0x746 <main+0x20c>
 750:	bc cf       	rjmp	.-136    	; 0x6ca <main+0x190>
			}
		 else
			{
		 if (counter == 200)
              {
	          ledband(temperaturdaten,330);
 752:	6a e4       	ldi	r22, 0x4A	; 74
 754:	71 e0       	ldi	r23, 0x01	; 1
 756:	c8 01       	movw	r24, r16
 758:	0e 94 83 01 	call	0x306	; 0x306 <ledband>
	          counter++;
 75c:	80 91 c3 01 	lds	r24, 0x01C3
 760:	8f 5f       	subi	r24, 0xFF	; 255
 762:	80 93 c3 01 	sts	0x01C3, r24
 766:	b1 cf       	rjmp	.-158    	; 0x6ca <main+0x190>
			{			
			if (qbi(PLAYER,FLAGS))
			    { // PLAYER 2
				 if (player2 > 10)
				     {
					for (uint8_t step = 1; step <= (player2 -10) ; step++)
 768:	80 91 c4 01 	lds	r24, 0x01C4
 76c:	8b 30       	cpi	r24, 0x0B	; 11
 76e:	58 f2       	brcs	.-106    	; 0x706 <main+0x1cc>
 770:	21 e0       	ldi	r18, 0x01	; 1
 772:	84 2d       	mov	r24, r4
 774:	95 2d       	mov	r25, r5
					    {
						LED_TASK[step][0]=1;
 776:	31 e0       	ldi	r19, 0x01	; 1
 778:	88 0f       	add	r24, r24
 77a:	99 1f       	adc	r25, r25
 77c:	fc 01       	movw	r30, r24
 77e:	e9 56       	subi	r30, 0x69	; 105
 780:	fe 4f       	sbci	r31, 0xFE	; 254
 782:	30 83       	st	Z, r19
			{			
			if (qbi(PLAYER,FLAGS))
			    { // PLAYER 2
				 if (player2 > 10)
				     {
					for (uint8_t step = 1; step <= (player2 -10) ; step++)
 784:	2f 5f       	subi	r18, 0xFF	; 255
 786:	40 91 c4 01 	lds	r20, 0x01C4
 78a:	82 2f       	mov	r24, r18
 78c:	90 e0       	ldi	r25, 0x00	; 0
 78e:	49 50       	subi	r20, 0x09	; 9
 790:	55 0b       	sbc	r21, r21
 792:	24 17       	cp	r18, r20
 794:	15 06       	cpc	r1, r21
 796:	84 f3       	brlt	.-32     	; 0x778 <main+0x23e>
 798:	b6 cf       	rjmp	.-148    	; 0x706 <main+0x1cc>
					     {
						 LED_TASK[1][0]=1;
					     }
					 else
					     {
						 LED_TASK[1][0]=0;
 79a:	f5 01       	movw	r30, r10
 79c:	12 82       	std	Z+2, r1	; 0x02
 79e:	b3 cf       	rjmp	.-154    	; 0x706 <main+0x1cc>
				     }	 
				
			    } 
			else
			   { //PLAYER 1   
				if (player1 > 10)
 7a0:	80 91 95 01 	lds	r24, 0x0195
 7a4:	8b 30       	cpi	r24, 0x0B	; 11
 7a6:	40 f4       	brcc	.+16     	; 0x7b8 <main+0x27e>
						LED_TASK[step][0]=1;
					    }
				   }
				 else
				   {
					if (qbi(4,counter))
 7a8:	80 91 c3 01 	lds	r24, 0x01C3
 7ac:	84 ff       	sbrs	r24, 4
 7ae:	1e c0       	rjmp	.+60     	; 0x7ec <main+0x2b2>
					   {
					   LED_TASK[1][0]=1;
 7b0:	81 e0       	ldi	r24, 0x01	; 1
 7b2:	f5 01       	movw	r30, r10
 7b4:	82 83       	std	Z+2, r24	; 0x02
 7b6:	a7 cf       	rjmp	.-178    	; 0x706 <main+0x1cc>
			    } 
			else
			   { //PLAYER 1   
				if (player1 > 10)
				   {
					for (uint8_t step = 1; step <= (player1 -10) ; step++)
 7b8:	80 91 95 01 	lds	r24, 0x0195
 7bc:	8b 30       	cpi	r24, 0x0B	; 11
 7be:	08 f4       	brcc	.+2      	; 0x7c2 <main+0x288>
 7c0:	a2 cf       	rjmp	.-188    	; 0x706 <main+0x1cc>
 7c2:	21 e0       	ldi	r18, 0x01	; 1
 7c4:	84 2d       	mov	r24, r4
 7c6:	95 2d       	mov	r25, r5
					    {
						LED_TASK[step][0]=1;
 7c8:	31 e0       	ldi	r19, 0x01	; 1
 7ca:	88 0f       	add	r24, r24
 7cc:	99 1f       	adc	r25, r25
 7ce:	fc 01       	movw	r30, r24
 7d0:	e9 56       	subi	r30, 0x69	; 105
 7d2:	fe 4f       	sbci	r31, 0xFE	; 254
 7d4:	30 83       	st	Z, r19
			    } 
			else
			   { //PLAYER 1   
				if (player1 > 10)
				   {
					for (uint8_t step = 1; step <= (player1 -10) ; step++)
 7d6:	2f 5f       	subi	r18, 0xFF	; 255
 7d8:	40 91 95 01 	lds	r20, 0x0195
 7dc:	82 2f       	mov	r24, r18
 7de:	90 e0       	ldi	r25, 0x00	; 0
 7e0:	49 50       	subi	r20, 0x09	; 9
 7e2:	55 0b       	sbc	r21, r21
 7e4:	24 17       	cp	r18, r20
 7e6:	15 06       	cpc	r1, r21
 7e8:	84 f3       	brlt	.-32     	; 0x7ca <main+0x290>
 7ea:	8d cf       	rjmp	.-230    	; 0x706 <main+0x1cc>
					   {
					   LED_TASK[1][0]=1;
					   } 
					else
					   {
					   LED_TASK[1][0]=0;   
 7ec:	f5 01       	movw	r30, r10
 7ee:	12 82       	std	Z+2, r1	; 0x02
 7f0:	8a cf       	rjmp	.-236    	; 0x706 <main+0x1cc>
Uebergabe der Geschwindigkeit des Wuerfels
******************************************************************************/		 
		 
		 if (drehaktiv)
              {
              wuerfellos(3);                  
 7f2:	83 e0       	ldi	r24, 0x03	; 3
 7f4:	0e 94 49 01 	call	0x292	; 0x292 <wuerfellos>
 7f8:	8a cf       	rjmp	.-236    	; 0x70e <main+0x1d4>

000007fa <__vector_16>:
INTERRUPT Timer 0 Timerueberlauf
Einsprung alle XX ms
Dieser Timer wird fuer den Multiplexer genutzt
*******************************************************************************/
ISR(TIMER0_OVF_vect)
{
 7fa:	1f 92       	push	r1
 7fc:	0f 92       	push	r0
 7fe:	0f b6       	in	r0, 0x3f	; 63
 800:	0f 92       	push	r0
 802:	11 24       	eor	r1, r1
 804:	2f 93       	push	r18
 806:	3f 93       	push	r19
 808:	4f 93       	push	r20
 80a:	5f 93       	push	r21
 80c:	6f 93       	push	r22
 80e:	7f 93       	push	r23
 810:	8f 93       	push	r24
 812:	9f 93       	push	r25
 814:	af 93       	push	r26
 816:	bf 93       	push	r27
 818:	ef 93       	push	r30
 81a:	ff 93       	push	r31


if ( (LED_TASK[LED_Timer][0]) && ( taskcount < 1 ) )
 81c:	80 91 c0 01 	lds	r24, 0x01C0
 820:	e8 2f       	mov	r30, r24
 822:	f0 e0       	ldi	r31, 0x00	; 0
 824:	ee 0f       	add	r30, r30
 826:	ff 1f       	adc	r31, r31
 828:	e9 56       	subi	r30, 0x69	; 105
 82a:	fe 4f       	sbci	r31, 0xFE	; 254
 82c:	90 81       	ld	r25, Z
 82e:	99 23       	and	r25, r25
 830:	21 f0       	breq	.+8      	; 0x83a <__vector_16+0x40>
 832:	90 91 bf 01 	lds	r25, 0x01BF
 836:	99 23       	and	r25, r25
 838:	e1 f0       	breq	.+56     	; 0x872 <__vector_16+0x78>
    {
    zeilenwahl(LED_Timer);  // LED Ein
    }
else
    {
    zeilenwahl(0);          // LED Aus 
 83a:	80 e0       	ldi	r24, 0x00	; 0
 83c:	0e 94 b0 01 	call	0x360	; 0x360 <zeilenwahl>
    }
taskcount++;
 840:	80 91 bf 01 	lds	r24, 0x01BF
 844:	8f 5f       	subi	r24, 0xFF	; 255
 846:	80 93 bf 01 	sts	0x01BF, r24
if (taskcount > (MAX_HELL -LED_HELLIGKEIT))
 84a:	90 91 96 01 	lds	r25, 0x0196
 84e:	21 e1       	ldi	r18, 0x11	; 17
 850:	30 e0       	ldi	r19, 0x00	; 0
 852:	29 1b       	sub	r18, r25
 854:	31 09       	sbc	r19, r1
 856:	82 17       	cp	r24, r18
 858:	13 06       	cpc	r1, r19
 85a:	19 f0       	breq	.+6      	; 0x862 <__vector_16+0x68>
 85c:	14 f0       	brlt	.+4      	; 0x862 <__vector_16+0x68>
    {
    taskcount = 0;
 85e:	10 92 bf 01 	sts	0x01BF, r1
    }

LED_Timer++;
 862:	80 91 c0 01 	lds	r24, 0x01C0
 866:	8f 5f       	subi	r24, 0xFF	; 255
if (LED_Timer > LED_ANZAHL)
 868:	84 31       	cpi	r24, 0x14	; 20
 86a:	30 f4       	brcc	.+12     	; 0x878 <__vector_16+0x7e>
if (taskcount > (MAX_HELL -LED_HELLIGKEIT))
    {
    taskcount = 0;
    }

LED_Timer++;
 86c:	80 93 c0 01 	sts	0x01C0, r24
 870:	06 c0       	rjmp	.+12     	; 0x87e <__vector_16+0x84>
{


if ( (LED_TASK[LED_Timer][0]) && ( taskcount < 1 ) )
    {
    zeilenwahl(LED_Timer);  // LED Ein
 872:	0e 94 b0 01 	call	0x360	; 0x360 <zeilenwahl>
 876:	e4 cf       	rjmp	.-56     	; 0x840 <__vector_16+0x46>
    }

LED_Timer++;
if (LED_Timer > LED_ANZAHL)
    {
    LED_Timer = 1;
 878:	81 e0       	ldi	r24, 0x01	; 1
 87a:	80 93 c0 01 	sts	0x01C0, r24
    }


}
 87e:	ff 91       	pop	r31
 880:	ef 91       	pop	r30
 882:	bf 91       	pop	r27
 884:	af 91       	pop	r26
 886:	9f 91       	pop	r25
 888:	8f 91       	pop	r24
 88a:	7f 91       	pop	r23
 88c:	6f 91       	pop	r22
 88e:	5f 91       	pop	r21
 890:	4f 91       	pop	r20
 892:	3f 91       	pop	r19
 894:	2f 91       	pop	r18
 896:	0f 90       	pop	r0
 898:	0f be       	out	0x3f, r0	; 63
 89a:	0f 90       	pop	r0
 89c:	1f 90       	pop	r1
 89e:	18 95       	reti

000008a0 <__vector_14>:
/******************************************************************************
INTERRUPT Timer 0 Vergleich A 
Wird nicht genutzt
******************************************************************************/
ISR (TIMER0_COMPA_vect)
{
 8a0:	1f 92       	push	r1
 8a2:	0f 92       	push	r0
 8a4:	0f b6       	in	r0, 0x3f	; 63
 8a6:	0f 92       	push	r0
 8a8:	11 24       	eor	r1, r1

}
 8aa:	0f 90       	pop	r0
 8ac:	0f be       	out	0x3f, r0	; 63
 8ae:	0f 90       	pop	r0
 8b0:	1f 90       	pop	r1
 8b2:	18 95       	reti

000008b4 <__vector_9>:
Setzt UART nach Zeit X wieder in den Empfangsmodus 
Zufallsgenerator fuer den Wuerfel
******************************************************************************/

ISR(TIMER2_OVF_vect)
{
 8b4:	1f 92       	push	r1
 8b6:	0f 92       	push	r0
 8b8:	0f b6       	in	r0, 0x3f	; 63
 8ba:	0f 92       	push	r0
 8bc:	11 24       	eor	r1, r1
 8be:	2f 93       	push	r18
 8c0:	3f 93       	push	r19
 8c2:	4f 93       	push	r20
 8c4:	5f 93       	push	r21
 8c6:	6f 93       	push	r22
 8c8:	7f 93       	push	r23
 8ca:	8f 93       	push	r24
 8cc:	9f 93       	push	r25
 8ce:	af 93       	push	r26
 8d0:	bf 93       	push	r27
 8d2:	ef 93       	push	r30
 8d4:	ff 93       	push	r31
    
// Funktion zum Ruecksetzen des aktiven Sendekanals der Schnittstelle RS485

#if UART_DEBUG == 1
    uart_timer_action();
 8d6:	0e 94 a9 06 	call	0xd52	; 0xd52 <uart_timer_action>
#endif
	
// Test Zufallsgenerator fuer den Wuerfel	
if ( qbi(WUERFEL_7,FLAGS) )
 8da:	80 91 c5 01 	lds	r24, 0x01C5
 8de:	81 ff       	sbrs	r24, 1
 8e0:	2a c0       	rjmp	.+84     	; 0x936 <__vector_9+0x82>
     {
     if (zufall >= 7)
 8e2:	80 91 92 01 	lds	r24, 0x0192
 8e6:	87 30       	cpi	r24, 0x07	; 7
 8e8:	10 f0       	brcs	.+4      	; 0x8ee <__vector_9+0x3a>
         {
	     zufall = 0;
 8ea:	10 92 92 01 	sts	0x0192, r1
    if (zufall >= 6)
          {
          zufall = 0;
          }	   
    }	
zufall++;
 8ee:	80 91 92 01 	lds	r24, 0x0192
 8f2:	8f 5f       	subi	r24, 0xFF	; 255
 8f4:	80 93 92 01 	sts	0x0192, r24
counter++;
 8f8:	80 91 c3 01 	lds	r24, 0x01C3
 8fc:	8f 5f       	subi	r24, 0xFF	; 255
 8fe:	80 93 c3 01 	sts	0x01C3, r24
wzeiger++;
 902:	80 91 c6 01 	lds	r24, 0x01C6
 906:	90 91 c7 01 	lds	r25, 0x01C7
 90a:	01 96       	adiw	r24, 0x01	; 1
 90c:	90 93 c7 01 	sts	0x01C7, r25
 910:	80 93 c6 01 	sts	0x01C6, r24
}
 914:	ff 91       	pop	r31
 916:	ef 91       	pop	r30
 918:	bf 91       	pop	r27
 91a:	af 91       	pop	r26
 91c:	9f 91       	pop	r25
 91e:	8f 91       	pop	r24
 920:	7f 91       	pop	r23
 922:	6f 91       	pop	r22
 924:	5f 91       	pop	r21
 926:	4f 91       	pop	r20
 928:	3f 91       	pop	r19
 92a:	2f 91       	pop	r18
 92c:	0f 90       	pop	r0
 92e:	0f be       	out	0x3f, r0	; 63
 930:	0f 90       	pop	r0
 932:	1f 90       	pop	r1
 934:	18 95       	reti
	     zufall = 0;
         }
     }
else
	{
    if (zufall >= 6)
 936:	80 91 92 01 	lds	r24, 0x0192
 93a:	86 30       	cpi	r24, 0x06	; 6
 93c:	c0 f2       	brcs	.-80     	; 0x8ee <__vector_9+0x3a>
          {
          zufall = 0;
 93e:	10 92 92 01 	sts	0x0192, r1
 942:	d5 cf       	rjmp	.-86     	; 0x8ee <__vector_9+0x3a>

00000944 <__vector_18>:
INTERRUPT ROUTINE fuer UART, schreibt empfangenes Zeichen in den BUFFER
Empfangene Zeichen werden in den Puffer geschrieben 
Ist der Zeiger am Ende des Puffesr wird dieser an den Anfang gesetzt
******************************************************************************/
ISR(USART_RX_vect)
{
 944:	1f 92       	push	r1
 946:	0f 92       	push	r0
 948:	0f b6       	in	r0, 0x3f	; 63
 94a:	0f 92       	push	r0
 94c:	11 24       	eor	r1, r1
 94e:	8f 93       	push	r24
 950:	9f 93       	push	r25
 952:	ef 93       	push	r30
 954:	ff 93       	push	r31
  puffer[schreibzeiger] = UDR0;
 956:	80 91 ca 01 	lds	r24, 0x01CA
 95a:	90 91 c6 00 	lds	r25, 0x00C6
 95e:	e8 2f       	mov	r30, r24
 960:	f0 e0       	ldi	r31, 0x00	; 0
 962:	e7 52       	subi	r30, 0x27	; 39
 964:	fe 4f       	sbci	r31, 0xFE	; 254
 966:	90 83       	st	Z, r25
  schreibzeiger++;
 968:	91 e0       	ldi	r25, 0x01	; 1
 96a:	98 0f       	add	r25, r24
  if (schreibzeiger == PUFFER_GROESSE)
 96c:	89 3f       	cpi	r24, 0xF9	; 249
 96e:	59 f0       	breq	.+22     	; 0x986 <__vector_18+0x42>
Ist der Zeiger am Ende des Puffesr wird dieser an den Anfang gesetzt
******************************************************************************/
ISR(USART_RX_vect)
{
  puffer[schreibzeiger] = UDR0;
  schreibzeiger++;
 970:	90 93 ca 01 	sts	0x01CA, r25
  if (schreibzeiger == PUFFER_GROESSE)
    schreibzeiger = 0;
}
 974:	ff 91       	pop	r31
 976:	ef 91       	pop	r30
 978:	9f 91       	pop	r25
 97a:	8f 91       	pop	r24
 97c:	0f 90       	pop	r0
 97e:	0f be       	out	0x3f, r0	; 63
 980:	0f 90       	pop	r0
 982:	1f 90       	pop	r1
 984:	18 95       	reti
ISR(USART_RX_vect)
{
  puffer[schreibzeiger] = UDR0;
  schreibzeiger++;
  if (schreibzeiger == PUFFER_GROESSE)
    schreibzeiger = 0;
 986:	10 92 ca 01 	sts	0x01CA, r1
}
 98a:	f4 cf       	rjmp	.-24     	; 0x974 <__vector_18+0x30>

0000098c <UART_init>:
Aktivieren der Betriebsart Senden und Empfangen
Aktivieren des Empfangs Interrupts 
*****************************************************************************************/
void UART_init(void)
{
    UBRR0H = HIGH(USARTSPEED);
 98c:	10 92 c5 00 	sts	0x00C5, r1
    UBRR0L = LOW(USARTSPEED);
 990:	86 e1       	ldi	r24, 0x16	; 22
 992:	80 93 c4 00 	sts	0x00C4, r24
    UCSR0B = _BV(TXEN0) | _BV(RXEN0) | _BV(RXCIE0);
 996:	88 e9       	ldi	r24, 0x98	; 152
 998:	80 93 c1 00 	sts	0x00C1, r24
}
 99c:	08 95       	ret

0000099e <UART_SendByte>:
/******************************************************************************
Sendet ein Byte ueber die UART
******************************************************************************/
void UART_SendByte(uint8_t data)
{
    SENDEN_AKTIV;                         // RX > TX Umschaltung
 99e:	45 9a       	sbi	0x08, 5	; 8
    rucksetzcount = 3;                    // Delay zur Rueckschaltung RX
 9a0:	93 e0       	ldi	r25, 0x03	; 3
 9a2:	90 93 d8 01 	sts	0x01D8, r25
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 9a6:	ef ee       	ldi	r30, 0xEF	; 239
 9a8:	f3 e2       	ldi	r31, 0x23	; 35
 9aa:	31 97       	sbiw	r30, 0x01	; 1
 9ac:	f1 f7       	brne	.-4      	; 0x9aa <UART_SendByte+0xc>
 9ae:	00 c0       	rjmp	.+0      	; 0x9b0 <UART_SendByte+0x12>
 9b0:	00 00       	nop
    _delay_ms(10);
    while (bit_is_clear(UCSR0A, UDRE0));   // wartet auf UART Ready
 9b2:	e0 ec       	ldi	r30, 0xC0	; 192
 9b4:	f0 e0       	ldi	r31, 0x00	; 0
 9b6:	90 81       	ld	r25, Z
 9b8:	95 ff       	sbrs	r25, 5
 9ba:	fd cf       	rjmp	.-6      	; 0x9b6 <UART_SendByte+0x18>
    UDR0 = data;
 9bc:	80 93 c6 00 	sts	0x00C6, r24
}
 9c0:	08 95       	ret

000009c2 <putstring>:

/******************************************************************************
sendet einen String ueber UART
******************************************************************************/
void putstring(char *s)
{
 9c2:	cf 93       	push	r28
 9c4:	df 93       	push	r29
 9c6:	c8 2f       	mov	r28, r24
 9c8:	d9 2f       	mov	r29, r25
    while (*s != 0)
 9ca:	88 81       	ld	r24, Y
 9cc:	88 23       	and	r24, r24
 9ce:	31 f0       	breq	.+12     	; 0x9dc <putstring+0x1a>
 9d0:	21 96       	adiw	r28, 0x01	; 1
    {
        UART_SendByte(*s++);
 9d2:	0e 94 cf 04 	call	0x99e	; 0x99e <UART_SendByte>
/******************************************************************************
sendet einen String ueber UART
******************************************************************************/
void putstring(char *s)
{
    while (*s != 0)
 9d6:	89 91       	ld	r24, Y+
 9d8:	81 11       	cpse	r24, r1
 9da:	fb cf       	rjmp	.-10     	; 0x9d2 <putstring+0x10>
    {
        UART_SendByte(*s++);
    }
}
 9dc:	df 91       	pop	r29
 9de:	cf 91       	pop	r28
 9e0:	08 95       	ret

000009e2 <errorcodeu>:

/******************************************************************************
sendet den Fehlercode (Wandlung Hexzahl >> ASCII)
******************************************************************************/
void errorcodeu(uint8_t zahl)
{
 9e2:	cf 93       	push	r28
    uint8_t temp;

    temp = zahl % 10;                       // niederwertigste Ziffer
 9e4:	cd ec       	ldi	r28, 0xCD	; 205
 9e6:	8c 9f       	mul	r24, r28
 9e8:	c1 2d       	mov	r28, r1
 9ea:	11 24       	eor	r1, r1
 9ec:	c6 95       	lsr	r28
 9ee:	c6 95       	lsr	r28
 9f0:	c6 95       	lsr	r28
 9f2:	9c 2f       	mov	r25, r28
 9f4:	99 0f       	add	r25, r25
 9f6:	99 0f       	add	r25, r25
 9f8:	c9 0f       	add	r28, r25
 9fa:	cc 0f       	add	r28, r28
 9fc:	98 2f       	mov	r25, r24
 9fe:	9c 1b       	sub	r25, r28
 a00:	c9 2f       	mov	r28, r25
    zahl = zahl / 10;

    if (zahl != 0)
 a02:	8a 30       	cpi	r24, 0x0A	; 10
 a04:	30 f4       	brcc	.+12     	; 0xa12 <errorcodeu+0x30>
      errorcodeu(zahl);  // Rekursion fÃ¼r fÃ¼hrende Ziffern

    UART_SendByte(temp + '0');                    // Sendet Ziffer
 a06:	80 e3       	ldi	r24, 0x30	; 48
 a08:	8c 0f       	add	r24, r28
 a0a:	0e 94 cf 04 	call	0x99e	; 0x99e <UART_SendByte>
}
 a0e:	cf 91       	pop	r28
 a10:	08 95       	ret
void errorcodeu(uint8_t zahl)
{
    uint8_t temp;

    temp = zahl % 10;                       // niederwertigste Ziffer
    zahl = zahl / 10;
 a12:	9d ec       	ldi	r25, 0xCD	; 205
 a14:	89 9f       	mul	r24, r25
 a16:	81 2d       	mov	r24, r1
 a18:	11 24       	eor	r1, r1

    if (zahl != 0)
      errorcodeu(zahl);  // Rekursion fÃ¼r fÃ¼hrende Ziffern
 a1a:	86 95       	lsr	r24
 a1c:	86 95       	lsr	r24
 a1e:	86 95       	lsr	r24
 a20:	0e 94 f1 04 	call	0x9e2	; 0x9e2 <errorcodeu>
 a24:	f0 cf       	rjmp	.-32     	; 0xa06 <errorcodeu+0x24>

00000a26 <usart_getc_intr>:
  uint8_t schreibzeigernew;

  // Berechnung: Anzahl der Zeichen, wieviel sich im UART Buffer befinden
  // Kontrolle ob Uebertrag ausgeloesst wurde

  if (lesezeiger > schreibzeiger)                                         // Pruefung Uebertrag
 a26:	90 91 d7 01 	lds	r25, 0x01D7
 a2a:	80 91 ca 01 	lds	r24, 0x01CA
 a2e:	89 17       	cp	r24, r25
 a30:	08 f4       	brcc	.+2      	; 0xa34 <usart_getc_intr+0xe>
    {
      schreibzeigernew = PUFFER_GROESSE + schreibzeiger;                  // Uebertrag wird dazugerechnet
 a32:	86 50       	subi	r24, 0x06	; 6
  else
    {
      schreibzeigernew = schreibzeiger;                                   // Keine Korrektur notwendig
    }

  zeicheninbuffer = schreibzeigernew - lesezeiger;                        // Berechnung Anzahl der Zeichen(im UART Buffer)
 a34:	89 1b       	sub	r24, r25
 a36:	80 93 c9 01 	sts	0x01C9, r24
  if ( zeicheninbuffer > ( PUFFER_GROESSE - 20) )
    {
    //putstring("[ERR_BUF_OVERFLOW]");                                        // Error fuer Buffer Overflow !!!
    }

  if (zeicheninbuffer && !qbi(CONTROLLWORD_VOLL,UFLAGS))                       // Wenn Zeichen im Buffer und Controllbuffer nicht gesperrt ist erfolgt Abarbeitung
 a3a:	88 23       	and	r24, r24
 a3c:	09 f4       	brne	.+2      	; 0xa40 <usart_getc_intr+0x1a>
 a3e:	4b c0       	rjmp	.+150    	; 0xad6 <usart_getc_intr+0xb0>
 a40:	50 91 dd 02 	lds	r21, 0x02DD
 a44:	65 2f       	mov	r22, r21
 a46:	61 70       	andi	r22, 0x01	; 1
 a48:	50 fd       	sbrc	r21, 0
 a4a:	45 c0       	rjmp	.+138    	; 0xad6 <usart_getc_intr+0xb0>
 a4c:	20 91 cb 01 	lds	r18, 0x01CB
 a50:	30 91 cc 01 	lds	r19, 0x01CC
 a54:	81 50       	subi	r24, 0x01	; 1
            {
              CONTROLLWORD[UARTINDEX] = puffer[lesezeiger];                   // wird das aktuelle Zeichen im Buffer ins Controllword geschrieben
              UARTINDEX++;                                                    // INDEX wird um eins erhoeht
            }

          if ((UARTINDEX == CW_SIZE) && (CONTROLLWORD[0] == STEUERZEICHEN))  // Wenn Controllword gefuellt, wird geprueft ob es sich beim ersten Zeichen um das Steuerzeichen handelt
 a56:	a3 ed       	ldi	r26, 0xD3	; 211
 a58:	b2 e0       	ldi	r27, 0x02	; 2
 a5a:	15 c0       	rjmp	.+42     	; 0xa86 <usart_getc_intr+0x60>
          if (puffer[lesezeiger] == STEUERZEICHEN)                             // hier befindet sich das Steuerzeichen zum ruecksetzen des Zeigers
            {
              UARTINDEX = CLEAR;                                              // das Zeichen > setzt den INDEX vom Controllword auf 0 zurueck
            }

          if ((UARTINDEX >= 0) && (UARTINDEX < CW_SIZE))                     // nur wenn sich der INDEX zwischen 0 und BuffergroeÃe befindet
 a5c:	30 e0       	ldi	r19, 0x00	; 0
 a5e:	20 e0       	ldi	r18, 0x00	; 0
            {
              CONTROLLWORD[UARTINDEX] = puffer[lesezeiger];                   // wird das aktuelle Zeichen im Buffer ins Controllword geschrieben
 a60:	f9 01       	movw	r30, r18
 a62:	ed 52       	subi	r30, 0x2D	; 45
 a64:	fd 4f       	sbci	r31, 0xFD	; 253
 a66:	40 83       	st	Z, r20
              UARTINDEX++;                                                    // INDEX wird um eins erhoeht
 a68:	2f 5f       	subi	r18, 0xFF	; 255
 a6a:	3f 4f       	sbci	r19, 0xFF	; 255
            }

          if ((UARTINDEX == CW_SIZE) && (CONTROLLWORD[0] == STEUERZEICHEN))  // Wenn Controllword gefuellt, wird geprueft ob es sich beim ersten Zeichen um das Steuerzeichen handelt
 a6c:	25 30       	cpi	r18, 0x05	; 5
 a6e:	31 05       	cpc	r19, r1
 a70:	a9 f0       	breq	.+42     	; 0xa9c <usart_getc_intr+0x76>
            {
              sbi(CONTROLLWORD_VOLL,UFLAGS);                                  // wenn beide Bedingung erfuellt, wird Controllword fuer Weiterbearbeitung freigegeben und gleichzeitig fuers beschreiben gesperrt
              CONTROLLWORD[0] = 0;                                            // Controllword "0" loeschen
            }
          lesezeiger++;                                                       // Lesezeiger um eins erhoehen
 a72:	9f 5f       	subi	r25, 0xFF	; 255
          zeicheninbuffer--;                                                  // Da keine Neuberechnung in der Schleife fuer die Anzahl der Zeichen im UART Buffer erfolgt wird manuell eins runtergezaehlt
          if (lesezeiger==PUFFER_GROESSE) lesezeiger=0;                        // wenn Lesepuffer am Ende ruecksetzen
 a74:	9a 3f       	cpi	r25, 0xFA	; 250
 a76:	c1 f0       	breq	.+48     	; 0xaa8 <usart_getc_intr+0x82>
        }
      while (zeicheninbuffer && !qbi(CONTROLLWORD_VOLL,UFLAGS));          // wenn keine Zeichen mehr im UART Buffer sind oder das Controllword gesperrt wurde wird Schleife verlassen
 a78:	88 23       	and	r24, r24
 a7a:	19 f1       	breq	.+70     	; 0xac2 <usart_getc_intr+0x9c>
 a7c:	4f ef       	ldi	r20, 0xFF	; 255
 a7e:	48 0f       	add	r20, r24
 a80:	50 fd       	sbrc	r21, 0
 a82:	14 c0       	rjmp	.+40     	; 0xaac <usart_getc_intr+0x86>
 a84:	84 2f       	mov	r24, r20
  if (zeicheninbuffer && !qbi(CONTROLLWORD_VOLL,UFLAGS))                       // Wenn Zeichen im Buffer und Controllbuffer nicht gesperrt ist erfolgt Abarbeitung
    {
      do
        {

          if (puffer[lesezeiger] == STEUERZEICHEN)                             // hier befindet sich das Steuerzeichen zum ruecksetzen des Zeigers
 a86:	e9 2f       	mov	r30, r25
 a88:	f0 e0       	ldi	r31, 0x00	; 0
 a8a:	e7 52       	subi	r30, 0x27	; 39
 a8c:	fe 4f       	sbci	r31, 0xFE	; 254
 a8e:	40 81       	ld	r20, Z
 a90:	4e 33       	cpi	r20, 0x3E	; 62
 a92:	21 f3       	breq	.-56     	; 0xa5c <usart_getc_intr+0x36>
            {
              UARTINDEX = CLEAR;                                              // das Zeichen > setzt den INDEX vom Controllword auf 0 zurueck
            }

          if ((UARTINDEX >= 0) && (UARTINDEX < CW_SIZE))                     // nur wenn sich der INDEX zwischen 0 und BuffergroeÃe befindet
 a94:	25 30       	cpi	r18, 0x05	; 5
 a96:	31 05       	cpc	r19, r1
 a98:	48 f7       	brcc	.-46     	; 0xa6c <usart_getc_intr+0x46>
 a9a:	e2 cf       	rjmp	.-60     	; 0xa60 <usart_getc_intr+0x3a>
            {
              CONTROLLWORD[UARTINDEX] = puffer[lesezeiger];                   // wird das aktuelle Zeichen im Buffer ins Controllword geschrieben
              UARTINDEX++;                                                    // INDEX wird um eins erhoeht
            }

          if ((UARTINDEX == CW_SIZE) && (CONTROLLWORD[0] == STEUERZEICHEN))  // Wenn Controllword gefuellt, wird geprueft ob es sich beim ersten Zeichen um das Steuerzeichen handelt
 a9c:	4c 91       	ld	r20, X
 a9e:	4e 33       	cpi	r20, 0x3E	; 62
 aa0:	41 f7       	brne	.-48     	; 0xa72 <usart_getc_intr+0x4c>
            {
              sbi(CONTROLLWORD_VOLL,UFLAGS);                                  // wenn beide Bedingung erfuellt, wird Controllword fuer Weiterbearbeitung freigegeben und gleichzeitig fuers beschreiben gesperrt
 aa2:	51 60       	ori	r21, 0x01	; 1
              CONTROLLWORD[0] = 0;                                            // Controllword "0" loeschen
 aa4:	1c 92       	st	X, r1
 aa6:	e5 cf       	rjmp	.-54     	; 0xa72 <usart_getc_intr+0x4c>
            }
          lesezeiger++;                                                       // Lesezeiger um eins erhoehen
          zeicheninbuffer--;                                                  // Da keine Neuberechnung in der Schleife fuer die Anzahl der Zeichen im UART Buffer erfolgt wird manuell eins runtergezaehlt
          if (lesezeiger==PUFFER_GROESSE) lesezeiger=0;                        // wenn Lesepuffer am Ende ruecksetzen
 aa8:	96 2f       	mov	r25, r22
 aaa:	e6 cf       	rjmp	.-52     	; 0xa78 <usart_getc_intr+0x52>
 aac:	90 93 d7 01 	sts	0x01D7, r25
 ab0:	30 93 cc 01 	sts	0x01CC, r19
 ab4:	20 93 cb 01 	sts	0x01CB, r18
 ab8:	50 93 dd 02 	sts	0x02DD, r21
 abc:	80 93 c9 01 	sts	0x01C9, r24
 ac0:	08 95       	ret
 ac2:	90 93 d7 01 	sts	0x01D7, r25
 ac6:	30 93 cc 01 	sts	0x01CC, r19
 aca:	20 93 cb 01 	sts	0x01CB, r18
 ace:	50 93 dd 02 	sts	0x02DD, r21
 ad2:	10 92 c9 01 	sts	0x01C9, r1
        }
      while (zeicheninbuffer && !qbi(CONTROLLWORD_VOLL,UFLAGS));          // wenn keine Zeichen mehr im UART Buffer sind oder das Controllword gesperrt wurde wird Schleife verlassen

    }

}
 ad6:	08 95       	ret

00000ad8 <uart_action>:

/*
 * UART-Teil der Hauptschleife
 */
void uart_action(void)
{
 ad8:	cf 93       	push	r28
 ada:	df 93       	push	r29
  usart_getc_intr();                      // CHECK und Verarbeitung des UART Buffers
 adc:	0e 94 13 05 	call	0xa26	; 0xa26 <usart_getc_intr>

  if (qbi(CONTROLLWORD_VOLL,UFLAGS))       // Daten im Puffer > Run
 ae0:	80 91 dd 02 	lds	r24, 0x02DD
 ae4:	80 ff       	sbrs	r24, 0
 ae6:	07 c0       	rjmp	.+14     	; 0xaf6 <uart_action+0x1e>
    {
      cbi(CONTROLLWORD_VOLL,UFLAGS);      // Clear FLAG "RUN"
 ae8:	8e 7f       	andi	r24, 0xFE	; 254
 aea:	80 93 dd 02 	sts	0x02DD, r24
      if (CONTROLLWORD[1] == ADR485)       // Check Richtige Adresse
 aee:	80 91 d4 02 	lds	r24, 0x02D4
 af2:	8d 30       	cpi	r24, 0x0D	; 13
 af4:	39 f1       	breq	.+78     	; 0xb44 <uart_action+0x6c>
 4 = Multiplayer Mode   1 - 7
 5 = Temperaturanzeige mit DS1820
 6 = Test LEDs alle einschalten

******************************************************************************/
  if (qbi(TASTER,FLAGS))
 af6:	90 91 c5 01 	lds	r25, 0x01C5
 afa:	95 ff       	sbrs	r25, 5
 afc:	d7 c0       	rjmp	.+430    	; 0xcac <uart_action+0x1d4>
	{
      switch(mode)
 afe:	80 91 c2 01 	lds	r24, 0x01C2
 b02:	83 30       	cpi	r24, 0x03	; 3
 b04:	09 f4       	brne	.+2      	; 0xb08 <uart_action+0x30>
 b06:	d5 c0       	rjmp	.+426    	; 0xcb2 <uart_action+0x1da>
 b08:	08 f0       	brcs	.+2      	; 0xb0c <uart_action+0x34>
 b0a:	9e c0       	rjmp	.+316    	; 0xc48 <uart_action+0x170>
 b0c:	81 30       	cpi	r24, 0x01	; 1
 b0e:	09 f4       	brne	.+2      	; 0xb12 <uart_action+0x3a>
 b10:	ae c0       	rjmp	.+348    	; 0xc6e <uart_action+0x196>
 b12:	82 30       	cpi	r24, 0x02	; 2
 b14:	09 f0       	breq	.+2      	; 0xb18 <uart_action+0x40>
 b16:	80 c0       	rjmp	.+256    	; 0xc18 <uart_action+0x140>
          UART_SendByte(10);              // Ausgabe Return
          multi_player(0);                // Singelplayer
          break;

        case 2:	                        // Wuerfelsingelmode 1-7
          sbi(TEMP_OFF,FLAGS);			// Temperaturanzeige AUS
 b18:	94 60       	ori	r25, 0x04	; 4
 b1a:	90 93 c5 01 	sts	0x01C5, r25
          UART_SendByte(10);              // Ausgabe Return
 b1e:	8a e0       	ldi	r24, 0x0A	; 10
 b20:	0e 94 cf 04 	call	0x99e	; 0x99e <UART_SendByte>
          putstring("Wuerfel Spezialmode 7"); // Ausgabe Text
 b24:	8c e7       	ldi	r24, 0x7C	; 124
 b26:	91 e0       	ldi	r25, 0x01	; 1
 b28:	0e 94 e1 04 	call	0x9c2	; 0x9c2 <putstring>
          sbi(WUERFEL_7,FLAGS);			// Wuerfelspezialmode 7
 b2c:	80 91 c5 01 	lds	r24, 0x01C5
 b30:	82 60       	ori	r24, 0x02	; 2
 b32:	80 93 c5 01 	sts	0x01C5, r24
          UART_SendByte(10);              // Ausgabe Return
 b36:	8a e0       	ldi	r24, 0x0A	; 10
 b38:	0e 94 cf 04 	call	0x99e	; 0x99e <UART_SendByte>
          multi_player(0);                // Singelplayer
 b3c:	80 e0       	ldi	r24, 0x00	; 0
 b3e:	0e 94 6d 00 	call	0xda	; 0xda <multi_player>
          break;
 b42:	aa c0       	rjmp	.+340    	; 0xc98 <uart_action+0x1c0>
  if (qbi(CONTROLLWORD_VOLL,UFLAGS))       // Daten im Puffer > Run
    {
      cbi(CONTROLLWORD_VOLL,UFLAGS);      // Clear FLAG "RUN"
      if (CONTROLLWORD[1] == ADR485)       // Check Richtige Adresse
        {
          switch (CONTROLLWORD[2])         // Abarbeitung switch
 b44:	80 91 d5 02 	lds	r24, 0x02D5
 b48:	83 30       	cpi	r24, 0x03	; 3
 b4a:	e9 f1       	breq	.+122    	; 0xbc6 <uart_action+0xee>
 b4c:	a8 f0       	brcs	.+42     	; 0xb78 <uart_action+0xa0>
 b4e:	84 30       	cpi	r24, 0x04	; 4
 b50:	09 f4       	brne	.+2      	; 0xb54 <uart_action+0x7c>
 b52:	44 c0       	rjmp	.+136    	; 0xbdc <uart_action+0x104>
 b54:	85 30       	cpi	r24, 0x05	; 5
 b56:	79 f6       	brne	.-98     	; 0xaf6 <uart_action+0x1e>
                  errorcodeu(ztemp); //DEBUG
                }
              break;

            case 5:
              if (CONTROLLWORD[4] == ADR485)      // CRC CHECK
 b58:	80 91 d7 02 	lds	r24, 0x02D7
 b5c:	8d 30       	cpi	r24, 0x0D	; 13
 b5e:	59 f6       	brne	.-106    	; 0xaf6 <uart_action+0x1e>
                {
                  UART_SendByte(10);             // Ausgabe Return
 b60:	8a e0       	ldi	r24, 0x0A	; 10
 b62:	0e 94 cf 04 	call	0x99e	; 0x99e <UART_SendByte>
                  putstring("Multiplayer: ");   // Ausgabe Funktion
 b66:	88 e4       	ldi	r24, 0x48	; 72
 b68:	91 e0       	ldi	r25, 0x01	; 1
 b6a:	0e 94 e1 04 	call	0x9c2	; 0x9c2 <putstring>
                  multi_player(CONTROLLWORD[3]);
 b6e:	80 91 d6 02 	lds	r24, 0x02D6
 b72:	0e 94 6d 00 	call	0xda	; 0xda <multi_player>
 b76:	bf cf       	rjmp	.-130    	; 0xaf6 <uart_action+0x1e>
  if (qbi(CONTROLLWORD_VOLL,UFLAGS))       // Daten im Puffer > Run
    {
      cbi(CONTROLLWORD_VOLL,UFLAGS);      // Clear FLAG "RUN"
      if (CONTROLLWORD[1] == ADR485)       // Check Richtige Adresse
        {
          switch (CONTROLLWORD[2])         // Abarbeitung switch
 b78:	88 23       	and	r24, r24
 b7a:	c1 f0       	breq	.+48     	; 0xbac <uart_action+0xd4>
 b7c:	81 30       	cpi	r24, 0x01	; 1
 b7e:	09 f0       	breq	.+2      	; 0xb82 <uart_action+0xaa>
 b80:	ba cf       	rjmp	.-140    	; 0xaf6 <uart_action+0x1e>
                  UART_SendByte(10);               // Ausgabe Return
                }
              break;

            case 1:
              if (CONTROLLWORD[4] == ADR485)       // CRC CHECK
 b82:	80 91 d7 02 	lds	r24, 0x02D7
 b86:	8d 30       	cpi	r24, 0x0D	; 13
 b88:	09 f0       	breq	.+2      	; 0xb8c <uart_action+0xb4>
 b8a:	b5 cf       	rjmp	.-150    	; 0xaf6 <uart_action+0x1e>
                {
                  putstring("Wuerfelmode:");		// Ausgabe Text
 b8c:	80 e3       	ldi	r24, 0x30	; 48
 b8e:	91 e0       	ldi	r25, 0x01	; 1
 b90:	0e 94 e1 04 	call	0x9c2	; 0x9c2 <putstring>
                  errorcodeu(CONTROLLWORD[3]);	// Wuerfel Funktion wird festgelegt
 b94:	c3 ed       	ldi	r28, 0xD3	; 211
 b96:	d2 e0       	ldi	r29, 0x02	; 2
 b98:	8b 81       	ldd	r24, Y+3	; 0x03
 b9a:	0e 94 f1 04 	call	0x9e2	; 0x9e2 <errorcodeu>
                  mode = CONTROLLWORD[3];
 b9e:	8b 81       	ldd	r24, Y+3	; 0x03
 ba0:	80 93 c2 01 	sts	0x01C2, r24
                  UART_SendByte(10);              // Ausgabe Return
 ba4:	8a e0       	ldi	r24, 0x0A	; 10
 ba6:	0e 94 cf 04 	call	0x99e	; 0x99e <UART_SendByte>
 baa:	a5 cf       	rjmp	.-182    	; 0xaf6 <uart_action+0x1e>
      if (CONTROLLWORD[1] == ADR485)       // Check Richtige Adresse
        {
          switch (CONTROLLWORD[2])         // Abarbeitung switch
            {
            case 0:                     // Ausgabe Software Version
              if (CONTROLLWORD[4] == ADR485) // CRC CHECK 
 bac:	80 91 d7 02 	lds	r24, 0x02D7
 bb0:	8d 30       	cpi	r24, 0x0D	; 13
 bb2:	09 f0       	breq	.+2      	; 0xbb6 <uart_action+0xde>
 bb4:	a0 cf       	rjmp	.-192    	; 0xaf6 <uart_action+0x1e>
                {
                  putstring("Version 0.4");   // Ausgabe Versionstext Text
 bb6:	84 e2       	ldi	r24, 0x24	; 36
 bb8:	91 e0       	ldi	r25, 0x01	; 1
 bba:	0e 94 e1 04 	call	0x9c2	; 0x9c2 <putstring>
                  UART_SendByte(10);               // Ausgabe Return
 bbe:	8a e0       	ldi	r24, 0x0A	; 10
 bc0:	0e 94 cf 04 	call	0x99e	; 0x99e <UART_SendByte>
 bc4:	98 cf       	rjmp	.-208    	; 0xaf6 <uart_action+0x1e>
                  UART_SendByte(10);              // Ausgabe Return
                }
              break;

            case 3:
              if (CONTROLLWORD[4] == ADR485)       // CRC CHECK
 bc6:	80 91 d7 02 	lds	r24, 0x02D7
 bca:	8d 30       	cpi	r24, 0x0D	; 13
 bcc:	09 f0       	breq	.+2      	; 0xbd0 <uart_action+0xf8>
 bce:	93 cf       	rjmp	.-218    	; 0xaf6 <uart_action+0x1e>
                {
                  // Simulation Taster
                  sbi(TASTER,FLAGS); // DEBUG TASTER
 bd0:	80 91 c5 01 	lds	r24, 0x01C5
 bd4:	80 62       	ori	r24, 0x20	; 32
 bd6:	80 93 c5 01 	sts	0x01C5, r24
 bda:	8d cf       	rjmp	.-230    	; 0xaf6 <uart_action+0x1e>
                }
              break;

            case 4:
              if (CONTROLLWORD[4] == ADR485)      // CRC CHECK
 bdc:	80 91 d7 02 	lds	r24, 0x02D7
 be0:	8d 30       	cpi	r24, 0x0D	; 13
 be2:	09 f0       	breq	.+2      	; 0xbe6 <uart_action+0x10e>
 be4:	88 cf       	rjmp	.-240    	; 0xaf6 <uart_action+0x1e>
                {
                  ztemp = zufall;                // Zufahlszahl
 be6:	80 91 92 01 	lds	r24, 0x0192
 bea:	80 93 93 01 	sts	0x0193, r24
                  UART_SendByte(10);             // Ausgabe Return
 bee:	8a e0       	ldi	r24, 0x0A	; 10
 bf0:	0e 94 cf 04 	call	0x99e	; 0x99e <UART_SendByte>
                  putstring("wuerfeln: ");      // Ausgabe Versionstext Text
 bf4:	8d e3       	ldi	r24, 0x3D	; 61
 bf6:	91 e0       	ldi	r25, 0x01	; 1
 bf8:	0e 94 e1 04 	call	0x9c2	; 0x9c2 <putstring>
                  //drehaktiv = CONTROLLWORD[3];
                  drehaktiv = rand()%6+1;
 bfc:	0e 94 4f 07 	call	0xe9e	; 0xe9e <rand>
 c00:	66 e0       	ldi	r22, 0x06	; 6
 c02:	70 e0       	ldi	r23, 0x00	; 0
 c04:	0e 94 b9 06 	call	0xd72	; 0xd72 <__divmodhi4>
 c08:	8f 5f       	subi	r24, 0xFF	; 255
 c0a:	80 93 c8 01 	sts	0x01C8, r24
                  errorcodeu(ztemp); //DEBUG
 c0e:	80 91 93 01 	lds	r24, 0x0193
 c12:	0e 94 f1 04 	call	0x9e2	; 0x9e2 <errorcodeu>
 c16:	6f cf       	rjmp	.-290    	; 0xaf6 <uart_action+0x1e>
 6 = Test LEDs alle einschalten

******************************************************************************/
  if (qbi(TASTER,FLAGS))
	{
      switch(mode)
 c18:	81 11       	cpse	r24, r1
 c1a:	3e c0       	rjmp	.+124    	; 0xc98 <uart_action+0x1c0>
        {
        case 0:                         // Temperaturanzeige
          putstring("TEMPANZEIGE AN:");   // Ausgabe Text
 c1c:	86 e5       	ldi	r24, 0x56	; 86
 c1e:	91 e0       	ldi	r25, 0x01	; 1
 c20:	0e 94 e1 04 	call	0x9c2	; 0x9c2 <putstring>
          UART_SendByte(10);              // Ausgabe Return
 c24:	8a e0       	ldi	r24, 0x0A	; 10
 c26:	0e 94 cf 04 	call	0x99e	; 0x99e <UART_SendByte>
          cbi(TEMP_OFF,FLAGS);			// Temperaturanzeige AN
          cbi(TEMPISOFF,FLAGS);			// Ruecksetzen TEMPIS OFF
 c2a:	80 91 c5 01 	lds	r24, 0x01C5
 c2e:	83 7f       	andi	r24, 0xF3	; 243
 c30:	80 93 c5 01 	sts	0x01C5, r24
 c34:	e9 e9       	ldi	r30, 0x99	; 153
 c36:	f1 e0       	ldi	r31, 0x01	; 1
 c38:	8f eb       	ldi	r24, 0xBF	; 191
 c3a:	91 e0       	ldi	r25, 0x01	; 1
          for (uint8_t step = 1; step <= 19 ; step++)
            {
              LED_TASK[step][0] = 0;       // Anzeige loeschen
 c3c:	10 82       	st	Z, r1
 c3e:	32 96       	adiw	r30, 0x02	; 2
        case 0:                         // Temperaturanzeige
          putstring("TEMPANZEIGE AN:");   // Ausgabe Text
          UART_SendByte(10);              // Ausgabe Return
          cbi(TEMP_OFF,FLAGS);			// Temperaturanzeige AN
          cbi(TEMPISOFF,FLAGS);			// Ruecksetzen TEMPIS OFF
          for (uint8_t step = 1; step <= 19 ; step++)
 c40:	e8 17       	cp	r30, r24
 c42:	f9 07       	cpc	r31, r25
 c44:	d9 f7       	brne	.-10     	; 0xc3c <uart_action+0x164>
 c46:	28 c0       	rjmp	.+80     	; 0xc98 <uart_action+0x1c0>
 6 = Test LEDs alle einschalten

******************************************************************************/
  if (qbi(TASTER,FLAGS))
	{
      switch(mode)
 c48:	84 30       	cpi	r24, 0x04	; 4
 c4a:	09 f4       	brne	.+2      	; 0xc4e <uart_action+0x176>
 c4c:	5a c0       	rjmp	.+180    	; 0xd02 <uart_action+0x22a>
 c4e:	86 30       	cpi	r24, 0x06	; 6
 c50:	19 f5       	brne	.+70     	; 0xc98 <uart_action+0x1c0>
          break;

        case 6:
          // Alle LEDs an
          sbi(TEMP_OFF,FLAGS);			// Temperaturanzeige AUS
          sbi(TEMPISOFF,FLAGS); 
 c52:	9c 60       	ori	r25, 0x0C	; 12
 c54:	90 93 c5 01 	sts	0x01C5, r25
 c58:	e9 e9       	ldi	r30, 0x99	; 153
 c5a:	f1 e0       	ldi	r31, 0x01	; 1
 c5c:	2f eb       	ldi	r18, 0xBF	; 191
 c5e:	31 e0       	ldi	r19, 0x01	; 1
          for (uint8_t step = 1; step <= 19 ; step++)
            {
              LED_TASK[step][0] = 1;
 c60:	81 e0       	ldi	r24, 0x01	; 1
 c62:	80 83       	st	Z, r24
 c64:	32 96       	adiw	r30, 0x02	; 2

        case 6:
          // Alle LEDs an
          sbi(TEMP_OFF,FLAGS);			// Temperaturanzeige AUS
          sbi(TEMPISOFF,FLAGS); 
          for (uint8_t step = 1; step <= 19 ; step++)
 c66:	e2 17       	cp	r30, r18
 c68:	f3 07       	cpc	r31, r19
 c6a:	d9 f7       	brne	.-10     	; 0xc62 <uart_action+0x18a>
 c6c:	15 c0       	rjmp	.+42     	; 0xc98 <uart_action+0x1c0>
              LED_TASK[step][0] = 0;       // Anzeige loeschen
            }
          break;

        case 1:	                        // Wuerfelsingelmode 1-6
          sbi(TEMP_OFF,FLAGS);			// Temperaturanzeige AUS
 c6e:	94 60       	ori	r25, 0x04	; 4
 c70:	90 93 c5 01 	sts	0x01C5, r25
          UART_SendByte(10);              // Ausgabe Return
 c74:	8a e0       	ldi	r24, 0x0A	; 10
 c76:	0e 94 cf 04 	call	0x99e	; 0x99e <UART_SendByte>
          putstring("Wuerfel Spezialmode 6"); // Ausgabe Text
 c7a:	86 e6       	ldi	r24, 0x66	; 102
 c7c:	91 e0       	ldi	r25, 0x01	; 1
 c7e:	0e 94 e1 04 	call	0x9c2	; 0x9c2 <putstring>
          cbi(WUERFEL_7,FLAGS);			// Wuerfelspezialmode 6
 c82:	80 91 c5 01 	lds	r24, 0x01C5
 c86:	8d 7f       	andi	r24, 0xFD	; 253
 c88:	80 93 c5 01 	sts	0x01C5, r24
          UART_SendByte(10);              // Ausgabe Return
 c8c:	8a e0       	ldi	r24, 0x0A	; 10
 c8e:	0e 94 cf 04 	call	0x99e	; 0x99e <UART_SendByte>
          multi_player(0);                // Singelplayer
 c92:	80 e0       	ldi	r24, 0x00	; 0
 c94:	0e 94 6d 00 	call	0xda	; 0xda <multi_player>
              LED_TASK[step][0] = 1;
            }
          break;
		}

      counter++;
 c98:	80 91 c3 01 	lds	r24, 0x01C3
 c9c:	8f 5f       	subi	r24, 0xFF	; 255
 c9e:	80 93 c3 01 	sts	0x01C3, r24
      cbi(TASTER,FLAGS); // DEBUG TASTER
 ca2:	80 91 c5 01 	lds	r24, 0x01C5
 ca6:	8f 7d       	andi	r24, 0xDF	; 223
 ca8:	80 93 c5 01 	sts	0x01C5, r24
	}
}
 cac:	df 91       	pop	r29
 cae:	cf 91       	pop	r28
 cb0:	08 95       	ret
          UART_SendByte(10);              // Ausgabe Return
          multi_player(0);                // Singelplayer
          break;

        case 3:	                        // Wuerfel Multiplayer 1-6
          sbi(TEMP_OFF,FLAGS);			// Temperaturanzeige AUS
 cb2:	94 60       	ori	r25, 0x04	; 4
 cb4:	90 93 c5 01 	sts	0x01C5, r25
          UART_SendByte(10);              // Ausgabe Return
 cb8:	8a e0       	ldi	r24, 0x0A	; 10
 cba:	0e 94 cf 04 	call	0x99e	; 0x99e <UART_SendByte>
          putstring("Wuerfel Spezialmode 6"); // Ausgabe Text
 cbe:	86 e6       	ldi	r24, 0x66	; 102
 cc0:	91 e0       	ldi	r25, 0x01	; 1
 cc2:	0e 94 e1 04 	call	0x9c2	; 0x9c2 <putstring>
          cbi(WUERFEL_7,FLAGS);			// Wuerfelspezialmode 6
 cc6:	80 91 c5 01 	lds	r24, 0x01C5
 cca:	8d 7f       	andi	r24, 0xFD	; 253
 ccc:	80 93 c5 01 	sts	0x01C5, r24
          UART_SendByte(10);              // Ausgabe Return
 cd0:	8a e0       	ldi	r24, 0x0A	; 10
 cd2:	0e 94 cf 04 	call	0x99e	; 0x99e <UART_SendByte>
          if (qbi(PLAYER,FLAGS))
 cd6:	80 91 c5 01 	lds	r24, 0x01C5
 cda:	84 ff       	sbrs	r24, 4
 cdc:	09 c0       	rjmp	.+18     	; 0xcf0 <uart_action+0x218>
            {
              multi_player(1);                // Multiplayer	1
 cde:	81 e0       	ldi	r24, 0x01	; 1
 ce0:	0e 94 6d 00 	call	0xda	; 0xda <multi_player>
              cbi(PLAYER,FLAGS); // TEST
 ce4:	80 91 c5 01 	lds	r24, 0x01C5
 ce8:	8f 7e       	andi	r24, 0xEF	; 239
 cea:	80 93 c5 01 	sts	0x01C5, r24
 cee:	d4 cf       	rjmp	.-88     	; 0xc98 <uart_action+0x1c0>
            }
          else
            {
              multi_player(2);                // Multiplayer	2
 cf0:	82 e0       	ldi	r24, 0x02	; 2
 cf2:	0e 94 6d 00 	call	0xda	; 0xda <multi_player>
              sbi(PLAYER,FLAGS); //TEST
 cf6:	80 91 c5 01 	lds	r24, 0x01C5
 cfa:	80 61       	ori	r24, 0x10	; 16
 cfc:	80 93 c5 01 	sts	0x01C5, r24
 d00:	cb cf       	rjmp	.-106    	; 0xc98 <uart_action+0x1c0>
            }
          break;

        case 4:	                        // Wuerfelmultiplayer 1-7
          sbi(TEMP_OFF,FLAGS);			// Temperaturanzeige AUS
 d02:	94 60       	ori	r25, 0x04	; 4
 d04:	90 93 c5 01 	sts	0x01C5, r25
          UART_SendByte(10);              // Ausgabe Return
 d08:	8a e0       	ldi	r24, 0x0A	; 10
 d0a:	0e 94 cf 04 	call	0x99e	; 0x99e <UART_SendByte>
          putstring("Wuerfel Spezialmode 7"); // Ausgabe Text
 d0e:	8c e7       	ldi	r24, 0x7C	; 124
 d10:	91 e0       	ldi	r25, 0x01	; 1
 d12:	0e 94 e1 04 	call	0x9c2	; 0x9c2 <putstring>
          sbi(WUERFEL_7,FLAGS);			// Wuerfelspezialmode 7
 d16:	80 91 c5 01 	lds	r24, 0x01C5
 d1a:	82 60       	ori	r24, 0x02	; 2
 d1c:	80 93 c5 01 	sts	0x01C5, r24
          UART_SendByte(10);              // Ausgabe Return
 d20:	8a e0       	ldi	r24, 0x0A	; 10
 d22:	0e 94 cf 04 	call	0x99e	; 0x99e <UART_SendByte>
          if (qbi(PLAYER,FLAGS))
 d26:	80 91 c5 01 	lds	r24, 0x01C5
 d2a:	84 ff       	sbrs	r24, 4
 d2c:	09 c0       	rjmp	.+18     	; 0xd40 <uart_action+0x268>
            {
              multi_player(1);                // Multiplayer	1
 d2e:	81 e0       	ldi	r24, 0x01	; 1
 d30:	0e 94 6d 00 	call	0xda	; 0xda <multi_player>
              cbi(PLAYER,FLAGS); // TEST
 d34:	80 91 c5 01 	lds	r24, 0x01C5
 d38:	8f 7e       	andi	r24, 0xEF	; 239
 d3a:	80 93 c5 01 	sts	0x01C5, r24
 d3e:	ac cf       	rjmp	.-168    	; 0xc98 <uart_action+0x1c0>
            }
          else
            {
              multi_player(2);                // Multiplayer	2
 d40:	82 e0       	ldi	r24, 0x02	; 2
 d42:	0e 94 6d 00 	call	0xda	; 0xda <multi_player>
              sbi(PLAYER,FLAGS); //TEST
 d46:	80 91 c5 01 	lds	r24, 0x01C5
 d4a:	80 61       	ori	r24, 0x10	; 16
 d4c:	80 93 c5 01 	sts	0x01C5, r24
 d50:	a3 cf       	rjmp	.-186    	; 0xc98 <uart_action+0x1c0>

00000d52 <uart_timer_action>:

}

void uart_timer_action(void)
{
  if (rucksetzcount)
 d52:	80 91 d8 01 	lds	r24, 0x01D8
 d56:	88 23       	and	r24, r24
 d58:	49 f0       	breq	.+18     	; 0xd6c <uart_timer_action+0x1a>
    {
      if (rucksetzcount == 1)
 d5a:	80 91 d8 01 	lds	r24, 0x01D8
 d5e:	81 30       	cpi	r24, 0x01	; 1
 d60:	31 f0       	breq	.+12     	; 0xd6e <uart_timer_action+0x1c>
        {
          SENDEN_INAKTIV;
        }
      rucksetzcount--;
 d62:	80 91 d8 01 	lds	r24, 0x01D8
 d66:	81 50       	subi	r24, 0x01	; 1
 d68:	80 93 d8 01 	sts	0x01D8, r24
    }
}
 d6c:	08 95       	ret
{
  if (rucksetzcount)
    {
      if (rucksetzcount == 1)
        {
          SENDEN_INAKTIV;
 d6e:	45 98       	cbi	0x08, 5	; 8
 d70:	f8 cf       	rjmp	.-16     	; 0xd62 <uart_timer_action+0x10>

00000d72 <__divmodhi4>:
 d72:	97 fb       	bst	r25, 7
 d74:	07 2e       	mov	r0, r23
 d76:	16 f4       	brtc	.+4      	; 0xd7c <__divmodhi4+0xa>
 d78:	00 94       	com	r0
 d7a:	07 d0       	rcall	.+14     	; 0xd8a <__divmodhi4_neg1>
 d7c:	77 fd       	sbrc	r23, 7
 d7e:	09 d0       	rcall	.+18     	; 0xd92 <__divmodhi4_neg2>
 d80:	0e 94 d3 06 	call	0xda6	; 0xda6 <__udivmodhi4>
 d84:	07 fc       	sbrc	r0, 7
 d86:	05 d0       	rcall	.+10     	; 0xd92 <__divmodhi4_neg2>
 d88:	3e f4       	brtc	.+14     	; 0xd98 <__divmodhi4_exit>

00000d8a <__divmodhi4_neg1>:
 d8a:	90 95       	com	r25
 d8c:	81 95       	neg	r24
 d8e:	9f 4f       	sbci	r25, 0xFF	; 255
 d90:	08 95       	ret

00000d92 <__divmodhi4_neg2>:
 d92:	70 95       	com	r23
 d94:	61 95       	neg	r22
 d96:	7f 4f       	sbci	r23, 0xFF	; 255

00000d98 <__divmodhi4_exit>:
 d98:	08 95       	ret

00000d9a <__tablejump2__>:
 d9a:	ee 0f       	add	r30, r30
 d9c:	ff 1f       	adc	r31, r31
 d9e:	05 90       	lpm	r0, Z+
 da0:	f4 91       	lpm	r31, Z
 da2:	e0 2d       	mov	r30, r0
 da4:	09 94       	ijmp

00000da6 <__udivmodhi4>:
 da6:	aa 1b       	sub	r26, r26
 da8:	bb 1b       	sub	r27, r27
 daa:	51 e1       	ldi	r21, 0x11	; 17
 dac:	07 c0       	rjmp	.+14     	; 0xdbc <__udivmodhi4_ep>

00000dae <__udivmodhi4_loop>:
 dae:	aa 1f       	adc	r26, r26
 db0:	bb 1f       	adc	r27, r27
 db2:	a6 17       	cp	r26, r22
 db4:	b7 07       	cpc	r27, r23
 db6:	10 f0       	brcs	.+4      	; 0xdbc <__udivmodhi4_ep>
 db8:	a6 1b       	sub	r26, r22
 dba:	b7 0b       	sbc	r27, r23

00000dbc <__udivmodhi4_ep>:
 dbc:	88 1f       	adc	r24, r24
 dbe:	99 1f       	adc	r25, r25
 dc0:	5a 95       	dec	r21
 dc2:	a9 f7       	brne	.-22     	; 0xdae <__udivmodhi4_loop>
 dc4:	80 95       	com	r24
 dc6:	90 95       	com	r25
 dc8:	bc 01       	movw	r22, r24
 dca:	cd 01       	movw	r24, r26
 dcc:	08 95       	ret

00000dce <do_rand>:
 dce:	cf 92       	push	r12
 dd0:	df 92       	push	r13
 dd2:	ef 92       	push	r14
 dd4:	ff 92       	push	r15
 dd6:	cf 93       	push	r28
 dd8:	df 93       	push	r29
 dda:	cd b7       	in	r28, 0x3d	; 61
 ddc:	de b7       	in	r29, 0x3e	; 62
 dde:	2a 97       	sbiw	r28, 0x0a	; 10
 de0:	0f b6       	in	r0, 0x3f	; 63
 de2:	f8 94       	cli
 de4:	de bf       	out	0x3e, r29	; 62
 de6:	0f be       	out	0x3f, r0	; 63
 de8:	cd bf       	out	0x3d, r28	; 61
 dea:	89 87       	std	Y+9, r24	; 0x09
 dec:	9a 87       	std	Y+10, r25	; 0x0a
 dee:	a9 85       	ldd	r26, Y+9	; 0x09
 df0:	ba 85       	ldd	r27, Y+10	; 0x0a
 df2:	2d 91       	ld	r18, X+
 df4:	3d 91       	ld	r19, X+
 df6:	4d 91       	ld	r20, X+
 df8:	5c 91       	ld	r21, X
 dfa:	29 83       	std	Y+1, r18	; 0x01
 dfc:	3a 83       	std	Y+2, r19	; 0x02
 dfe:	4b 83       	std	Y+3, r20	; 0x03
 e00:	5c 83       	std	Y+4, r21	; 0x04
 e02:	23 2b       	or	r18, r19
 e04:	24 2b       	or	r18, r20
 e06:	25 2b       	or	r18, r21
 e08:	41 f4       	brne	.+16     	; 0xe1a <do_rand+0x4c>
 e0a:	24 e2       	ldi	r18, 0x24	; 36
 e0c:	39 ed       	ldi	r19, 0xD9	; 217
 e0e:	4b e5       	ldi	r20, 0x5B	; 91
 e10:	57 e0       	ldi	r21, 0x07	; 7
 e12:	29 83       	std	Y+1, r18	; 0x01
 e14:	3a 83       	std	Y+2, r19	; 0x02
 e16:	4b 83       	std	Y+3, r20	; 0x03
 e18:	5c 83       	std	Y+4, r21	; 0x04
 e1a:	69 81       	ldd	r22, Y+1	; 0x01
 e1c:	7a 81       	ldd	r23, Y+2	; 0x02
 e1e:	8b 81       	ldd	r24, Y+3	; 0x03
 e20:	9c 81       	ldd	r25, Y+4	; 0x04
 e22:	2d e1       	ldi	r18, 0x1D	; 29
 e24:	33 ef       	ldi	r19, 0xF3	; 243
 e26:	41 e0       	ldi	r20, 0x01	; 1
 e28:	50 e0       	ldi	r21, 0x00	; 0
 e2a:	0e 94 5f 07 	call	0xebe	; 0xebe <__divmodsi4>
 e2e:	69 01       	movw	r12, r18
 e30:	7a 01       	movw	r14, r20
 e32:	a7 ea       	ldi	r26, 0xA7	; 167
 e34:	b1 e4       	ldi	r27, 0x41	; 65
 e36:	9b 01       	movw	r18, r22
 e38:	ac 01       	movw	r20, r24
 e3a:	0e 94 7e 07 	call	0xefc	; 0xefc <__muluhisi3>
 e3e:	69 83       	std	Y+1, r22	; 0x01
 e40:	7a 83       	std	Y+2, r23	; 0x02
 e42:	8b 83       	std	Y+3, r24	; 0x03
 e44:	9c 83       	std	Y+4, r25	; 0x04
 e46:	ac ee       	ldi	r26, 0xEC	; 236
 e48:	b4 ef       	ldi	r27, 0xF4	; 244
 e4a:	a7 01       	movw	r20, r14
 e4c:	96 01       	movw	r18, r12
 e4e:	0e 94 8c 07 	call	0xf18	; 0xf18 <__mulohisi3>
 e52:	9b 01       	movw	r18, r22
 e54:	ac 01       	movw	r20, r24
 e56:	89 81       	ldd	r24, Y+1	; 0x01
 e58:	9a 81       	ldd	r25, Y+2	; 0x02
 e5a:	ab 81       	ldd	r26, Y+3	; 0x03
 e5c:	bc 81       	ldd	r27, Y+4	; 0x04
 e5e:	82 0f       	add	r24, r18
 e60:	93 1f       	adc	r25, r19
 e62:	a4 1f       	adc	r26, r20
 e64:	b5 1f       	adc	r27, r21
 e66:	b7 ff       	sbrs	r27, 7
 e68:	03 c0       	rjmp	.+6      	; 0xe70 <do_rand+0xa2>
 e6a:	01 97       	sbiw	r24, 0x01	; 1
 e6c:	a1 09       	sbc	r26, r1
 e6e:	b0 48       	sbci	r27, 0x80	; 128
 e70:	e9 85       	ldd	r30, Y+9	; 0x09
 e72:	fa 85       	ldd	r31, Y+10	; 0x0a
 e74:	80 83       	st	Z, r24
 e76:	91 83       	std	Z+1, r25	; 0x01
 e78:	a2 83       	std	Z+2, r26	; 0x02
 e7a:	b3 83       	std	Z+3, r27	; 0x03
 e7c:	9f 77       	andi	r25, 0x7F	; 127
 e7e:	2a 96       	adiw	r28, 0x0a	; 10
 e80:	0f b6       	in	r0, 0x3f	; 63
 e82:	f8 94       	cli
 e84:	de bf       	out	0x3e, r29	; 62
 e86:	0f be       	out	0x3f, r0	; 63
 e88:	cd bf       	out	0x3d, r28	; 61
 e8a:	df 91       	pop	r29
 e8c:	cf 91       	pop	r28
 e8e:	ff 90       	pop	r15
 e90:	ef 90       	pop	r14
 e92:	df 90       	pop	r13
 e94:	cf 90       	pop	r12
 e96:	08 95       	ret

00000e98 <rand_r>:
 e98:	0e 94 e7 06 	call	0xdce	; 0xdce <do_rand>
 e9c:	08 95       	ret

00000e9e <rand>:
 e9e:	80 e0       	ldi	r24, 0x00	; 0
 ea0:	91 e0       	ldi	r25, 0x01	; 1
 ea2:	0e 94 e7 06 	call	0xdce	; 0xdce <do_rand>
 ea6:	08 95       	ret

00000ea8 <srand>:
 ea8:	b0 e0       	ldi	r27, 0x00	; 0
 eaa:	a0 e0       	ldi	r26, 0x00	; 0
 eac:	80 93 00 01 	sts	0x0100, r24
 eb0:	90 93 01 01 	sts	0x0101, r25
 eb4:	a0 93 02 01 	sts	0x0102, r26
 eb8:	b0 93 03 01 	sts	0x0103, r27
 ebc:	08 95       	ret

00000ebe <__divmodsi4>:
 ebe:	05 2e       	mov	r0, r21
 ec0:	97 fb       	bst	r25, 7
 ec2:	1e f4       	brtc	.+6      	; 0xeca <__divmodsi4+0xc>
 ec4:	00 94       	com	r0
 ec6:	0e 94 76 07 	call	0xeec	; 0xeec <__negsi2>
 eca:	57 fd       	sbrc	r21, 7
 ecc:	07 d0       	rcall	.+14     	; 0xedc <__divmodsi4_neg2>
 ece:	0e 94 91 07 	call	0xf22	; 0xf22 <__udivmodsi4>
 ed2:	07 fc       	sbrc	r0, 7
 ed4:	03 d0       	rcall	.+6      	; 0xedc <__divmodsi4_neg2>
 ed6:	4e f4       	brtc	.+18     	; 0xeea <__divmodsi4_exit>
 ed8:	0c 94 76 07 	jmp	0xeec	; 0xeec <__negsi2>

00000edc <__divmodsi4_neg2>:
 edc:	50 95       	com	r21
 ede:	40 95       	com	r20
 ee0:	30 95       	com	r19
 ee2:	21 95       	neg	r18
 ee4:	3f 4f       	sbci	r19, 0xFF	; 255
 ee6:	4f 4f       	sbci	r20, 0xFF	; 255
 ee8:	5f 4f       	sbci	r21, 0xFF	; 255

00000eea <__divmodsi4_exit>:
 eea:	08 95       	ret

00000eec <__negsi2>:
 eec:	90 95       	com	r25
 eee:	80 95       	com	r24
 ef0:	70 95       	com	r23
 ef2:	61 95       	neg	r22
 ef4:	7f 4f       	sbci	r23, 0xFF	; 255
 ef6:	8f 4f       	sbci	r24, 0xFF	; 255
 ef8:	9f 4f       	sbci	r25, 0xFF	; 255
 efa:	08 95       	ret

00000efc <__muluhisi3>:
 efc:	0e 94 b3 07 	call	0xf66	; 0xf66 <__umulhisi3>
 f00:	a5 9f       	mul	r26, r21
 f02:	90 0d       	add	r25, r0
 f04:	b4 9f       	mul	r27, r20
 f06:	90 0d       	add	r25, r0
 f08:	a4 9f       	mul	r26, r20
 f0a:	80 0d       	add	r24, r0
 f0c:	91 1d       	adc	r25, r1
 f0e:	11 24       	eor	r1, r1
 f10:	08 95       	ret

00000f12 <__mulshisi3>:
 f12:	b7 ff       	sbrs	r27, 7
 f14:	0c 94 7e 07 	jmp	0xefc	; 0xefc <__muluhisi3>

00000f18 <__mulohisi3>:
 f18:	0e 94 7e 07 	call	0xefc	; 0xefc <__muluhisi3>
 f1c:	82 1b       	sub	r24, r18
 f1e:	93 0b       	sbc	r25, r19
 f20:	08 95       	ret

00000f22 <__udivmodsi4>:
 f22:	a1 e2       	ldi	r26, 0x21	; 33
 f24:	1a 2e       	mov	r1, r26
 f26:	aa 1b       	sub	r26, r26
 f28:	bb 1b       	sub	r27, r27
 f2a:	fd 01       	movw	r30, r26
 f2c:	0d c0       	rjmp	.+26     	; 0xf48 <__udivmodsi4_ep>

00000f2e <__udivmodsi4_loop>:
 f2e:	aa 1f       	adc	r26, r26
 f30:	bb 1f       	adc	r27, r27
 f32:	ee 1f       	adc	r30, r30
 f34:	ff 1f       	adc	r31, r31
 f36:	a2 17       	cp	r26, r18
 f38:	b3 07       	cpc	r27, r19
 f3a:	e4 07       	cpc	r30, r20
 f3c:	f5 07       	cpc	r31, r21
 f3e:	20 f0       	brcs	.+8      	; 0xf48 <__udivmodsi4_ep>
 f40:	a2 1b       	sub	r26, r18
 f42:	b3 0b       	sbc	r27, r19
 f44:	e4 0b       	sbc	r30, r20
 f46:	f5 0b       	sbc	r31, r21

00000f48 <__udivmodsi4_ep>:
 f48:	66 1f       	adc	r22, r22
 f4a:	77 1f       	adc	r23, r23
 f4c:	88 1f       	adc	r24, r24
 f4e:	99 1f       	adc	r25, r25
 f50:	1a 94       	dec	r1
 f52:	69 f7       	brne	.-38     	; 0xf2e <__udivmodsi4_loop>
 f54:	60 95       	com	r22
 f56:	70 95       	com	r23
 f58:	80 95       	com	r24
 f5a:	90 95       	com	r25
 f5c:	9b 01       	movw	r18, r22
 f5e:	ac 01       	movw	r20, r24
 f60:	bd 01       	movw	r22, r26
 f62:	cf 01       	movw	r24, r30
 f64:	08 95       	ret

00000f66 <__umulhisi3>:
 f66:	a2 9f       	mul	r26, r18
 f68:	b0 01       	movw	r22, r0
 f6a:	b3 9f       	mul	r27, r19
 f6c:	c0 01       	movw	r24, r0
 f6e:	a3 9f       	mul	r26, r19
 f70:	70 0d       	add	r23, r0
 f72:	81 1d       	adc	r24, r1
 f74:	11 24       	eor	r1, r1
 f76:	91 1d       	adc	r25, r1
 f78:	b2 9f       	mul	r27, r18
 f7a:	70 0d       	add	r23, r0
 f7c:	81 1d       	adc	r24, r1
 f7e:	11 24       	eor	r1, r1
 f80:	91 1d       	adc	r25, r1
 f82:	08 95       	ret

00000f84 <_exit>:
 f84:	f8 94       	cli

00000f86 <__stop_program>:
 f86:	ff cf       	rjmp	.-2      	; 0xf86 <__stop_program>
