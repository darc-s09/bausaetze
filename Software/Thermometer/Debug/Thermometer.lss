
Thermometer.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000066  00800100  00000a12  00000aa6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000a12  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000148  00800166  00800166  00000b0c  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000b0c  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 000000b8  00000000  00000000  00000b3c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000999  00000000  00000000  00000bf4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000230  00000000  00000000  0000158d  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000004a5  00000000  00000000  000017bd  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000210  00000000  00000000  00001c64  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000363  00000000  00000000  00001e74  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000006bb  00000000  00000000  000021d7  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000000a8  00000000  00000000  00002892  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 4e 00 	jmp	0x9c	; 0x9c <__ctors_end>
   4:	0c 94 6b 00 	jmp	0xd6	; 0xd6 <__bad_interrupt>
   8:	0c 94 6b 00 	jmp	0xd6	; 0xd6 <__bad_interrupt>
   c:	0c 94 6b 00 	jmp	0xd6	; 0xd6 <__bad_interrupt>
  10:	0c 94 6b 00 	jmp	0xd6	; 0xd6 <__bad_interrupt>
  14:	0c 94 6b 00 	jmp	0xd6	; 0xd6 <__bad_interrupt>
  18:	0c 94 6b 00 	jmp	0xd6	; 0xd6 <__bad_interrupt>
  1c:	0c 94 6b 00 	jmp	0xd6	; 0xd6 <__bad_interrupt>
  20:	0c 94 6b 00 	jmp	0xd6	; 0xd6 <__bad_interrupt>
  24:	0c 94 76 04 	jmp	0x8ec	; 0x8ec <__vector_9>
  28:	0c 94 6b 00 	jmp	0xd6	; 0xd6 <__bad_interrupt>
  2c:	0c 94 6b 00 	jmp	0xd6	; 0xd6 <__bad_interrupt>
  30:	0c 94 6b 00 	jmp	0xd6	; 0xd6 <__bad_interrupt>
  34:	0c 94 6b 00 	jmp	0xd6	; 0xd6 <__bad_interrupt>
  38:	0c 94 6c 04 	jmp	0x8d8	; 0x8d8 <__vector_14>
  3c:	0c 94 6b 00 	jmp	0xd6	; 0xd6 <__bad_interrupt>
  40:	0c 94 19 04 	jmp	0x832	; 0x832 <__vector_16>
  44:	0c 94 6b 00 	jmp	0xd6	; 0xd6 <__bad_interrupt>
  48:	0c 94 b6 04 	jmp	0x96c	; 0x96c <__vector_18>
  4c:	0c 94 6b 00 	jmp	0xd6	; 0xd6 <__bad_interrupt>
  50:	0c 94 6b 00 	jmp	0xd6	; 0xd6 <__bad_interrupt>
  54:	0c 94 6b 00 	jmp	0xd6	; 0xd6 <__bad_interrupt>
  58:	0c 94 6b 00 	jmp	0xd6	; 0xd6 <__bad_interrupt>
  5c:	0c 94 6b 00 	jmp	0xd6	; 0xd6 <__bad_interrupt>
  60:	0c 94 6b 00 	jmp	0xd6	; 0xd6 <__bad_interrupt>
  64:	0c 94 6b 00 	jmp	0xd6	; 0xd6 <__bad_interrupt>
  68:	81 00       	.word	0x0081	; ????
  6a:	85 00       	.word	0x0085	; ????
  6c:	8b 00       	.word	0x008b	; ????
  6e:	93 00       	.word	0x0093	; ????
  70:	9d 00       	.word	0x009d	; ????
  72:	a9 00       	.word	0x00a9	; ????
  74:	b7 00       	.word	0x00b7	; ????
  76:	4e 01       	movw	r8, r28
  78:	58 01       	movw	r10, r16
  7a:	62 01       	movw	r12, r4
  7c:	6c 01       	movw	r12, r24
  7e:	76 01       	movw	r14, r12
  80:	80 01       	movw	r16, r0
  82:	8a 01       	movw	r16, r20
  84:	94 01       	movw	r18, r8
  86:	9e 01       	movw	r18, r28
  88:	a8 01       	movw	r20, r16
  8a:	b2 01       	movw	r22, r4
  8c:	bc 01       	movw	r22, r24
  8e:	c6 01       	movw	r24, r12
  90:	d0 01       	movw	r26, r0
  92:	da 01       	movw	r26, r20
  94:	e4 01       	movw	r28, r8
  96:	ee 01       	movw	r28, r28
  98:	f8 01       	movw	r30, r16
  9a:	02 02       	muls	r16, r18

0000009c <__ctors_end>:
  9c:	11 24       	eor	r1, r1
  9e:	1f be       	out	0x3f, r1	; 63
  a0:	cf ef       	ldi	r28, 0xFF	; 255
  a2:	d4 e0       	ldi	r29, 0x04	; 4
  a4:	de bf       	out	0x3e, r29	; 62
  a6:	cd bf       	out	0x3d, r28	; 61

000000a8 <__do_copy_data>:
  a8:	11 e0       	ldi	r17, 0x01	; 1
  aa:	a0 e0       	ldi	r26, 0x00	; 0
  ac:	b1 e0       	ldi	r27, 0x01	; 1
  ae:	e2 e1       	ldi	r30, 0x12	; 18
  b0:	fa e0       	ldi	r31, 0x0A	; 10
  b2:	02 c0       	rjmp	.+4      	; 0xb8 <__do_copy_data+0x10>
  b4:	05 90       	lpm	r0, Z+
  b6:	0d 92       	st	X+, r0
  b8:	a6 36       	cpi	r26, 0x66	; 102
  ba:	b1 07       	cpc	r27, r17
  bc:	d9 f7       	brne	.-10     	; 0xb4 <__do_copy_data+0xc>

000000be <__do_clear_bss>:
  be:	22 e0       	ldi	r18, 0x02	; 2
  c0:	a6 e6       	ldi	r26, 0x66	; 102
  c2:	b1 e0       	ldi	r27, 0x01	; 1
  c4:	01 c0       	rjmp	.+2      	; 0xc8 <.do_clear_bss_start>

000000c6 <.do_clear_bss_loop>:
  c6:	1d 92       	st	X+, r1

000000c8 <.do_clear_bss_start>:
  c8:	ae 3a       	cpi	r26, 0xAE	; 174
  ca:	b2 07       	cpc	r27, r18
  cc:	e1 f7       	brne	.-8      	; 0xc6 <.do_clear_bss_loop>
  ce:	0e 94 24 03 	call	0x648	; 0x648 <main>
  d2:	0c 94 07 05 	jmp	0xa0e	; 0xa0e <_exit>

000000d6 <__bad_interrupt>:
  d6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000da <wuerfel>:

/***************************************************************************************
Ansteuerung Wuerfel (7 LED`s) Zahlen von 1 bis 7 sind moeglich
***************************************************************************************/
void wuerfel(uint8_t wzahl)
{
  da:	ef e8       	ldi	r30, 0x8F	; 143
  dc:	f1 e0       	ldi	r31, 0x01	; 1
  de:	2d e9       	ldi	r18, 0x9D	; 157
  e0:	31 e0       	ldi	r19, 0x01	; 1
for (uint8_t step = 11; step <= 17 ; step++)    // Abschalten aller 7 LED`s
    {
    LED_TASK[step][0]=0;                        // Abschalten aller LED`s auf dem Wuerfelfeld
  e2:	10 82       	st	Z, r1
  e4:	32 96       	adiw	r30, 0x02	; 2
/***************************************************************************************
Ansteuerung Wuerfel (7 LED`s) Zahlen von 1 bis 7 sind moeglich
***************************************************************************************/
void wuerfel(uint8_t wzahl)
{
for (uint8_t step = 11; step <= 17 ; step++)    // Abschalten aller 7 LED`s
  e6:	e2 17       	cp	r30, r18
  e8:	f3 07       	cpc	r31, r19
  ea:	d9 f7       	brne	.-10     	; 0xe2 <wuerfel+0x8>
    {
    LED_TASK[step][0]=0;                        // Abschalten aller LED`s auf dem Wuerfelfeld
    }
switch (wzahl)
  ec:	90 e0       	ldi	r25, 0x00	; 0
  ee:	fc 01       	movw	r30, r24
  f0:	31 97       	sbiw	r30, 0x01	; 1
  f2:	e7 30       	cpi	r30, 0x07	; 7
  f4:	f1 05       	cpc	r31, r1
  f6:	08 f0       	brcs	.+2      	; 0xfa <wuerfel+0x20>
  f8:	49 c0       	rjmp	.+146    	; 0x18c <wuerfel+0xb2>
  fa:	ec 5c       	subi	r30, 0xCC	; 204
  fc:	ff 4f       	sbci	r31, 0xFF	; 255
  fe:	0c 94 ed 04 	jmp	0x9da	; 0x9da <__tablejump2__>
    {
    case 1:                 // Wuerfel Zahl 1
    LED_TASK[11][0]=1;      // Wuerfel Zahl 1 >  LED 11
 102:	81 e0       	ldi	r24, 0x01	; 1
 104:	80 93 8f 01 	sts	0x018F, r24
    break;                  // Ende case
 108:	08 95       	ret

    case 2:                 // Wuerfel Zahl 2
    LED_TASK[14][0]=1;      // Wuerfel Zahl 2 >  LED 14
 10a:	81 e0       	ldi	r24, 0x01	; 1
 10c:	80 93 95 01 	sts	0x0195, r24
    LED_TASK[16][0]=1;      // Wuerfel Zahl 2 >  LED 16
 110:	80 93 99 01 	sts	0x0199, r24
    break;                  // Ende case
 114:	08 95       	ret

    case 3:                 // Wuerfel Zahl 3
    LED_TASK[11][0]=1;      // Wuerfel Zahl 3 >  LED 11
 116:	81 e0       	ldi	r24, 0x01	; 1
 118:	80 93 8f 01 	sts	0x018F, r24
    LED_TASK[14][0]=1;      // Wuerfel Zahl 3 >  LED 14
 11c:	80 93 95 01 	sts	0x0195, r24
    LED_TASK[16][0]=1;      // Wuerfel Zahl 3 >  LED 16
 120:	80 93 99 01 	sts	0x0199, r24
    break;                  // Ende case
 124:	08 95       	ret

    case 4:                 // Wuerfel Zahl 4
    LED_TASK[14][0]=1;      // Wuerfel Zahl 4 >  LED 14
 126:	81 e0       	ldi	r24, 0x01	; 1
 128:	80 93 95 01 	sts	0x0195, r24
    LED_TASK[15][0]=1;      // Wuerfel Zahl 4 >  LED 15
 12c:	80 93 97 01 	sts	0x0197, r24
    LED_TASK[16][0]=1;      // Wuerfel Zahl 4 >  LED 16
 130:	80 93 99 01 	sts	0x0199, r24
    LED_TASK[17][0]=1;      // Wuerfel Zahl 4 >  LED 17
 134:	80 93 9b 01 	sts	0x019B, r24
    break;                  // Ende case
 138:	08 95       	ret

    case 5:                 // Wuerfel Zahl 5
    LED_TASK[11][0]=1;      // Wuerfel Zahl 5 >  LED 11
 13a:	81 e0       	ldi	r24, 0x01	; 1
 13c:	80 93 8f 01 	sts	0x018F, r24
    LED_TASK[14][0]=1;      // Wuerfel Zahl 5 >  LED 14
 140:	80 93 95 01 	sts	0x0195, r24
    LED_TASK[15][0]=1;      // Wuerfel Zahl 5 >  LED 15
 144:	80 93 97 01 	sts	0x0197, r24
    LED_TASK[16][0]=1;      // Wuerfel Zahl 5 >  LED 16
 148:	80 93 99 01 	sts	0x0199, r24
    LED_TASK[17][0]=1;      // Wuerfel Zahl 5 >  LED 17
 14c:	80 93 9b 01 	sts	0x019B, r24
    break;                  // Ende case
 150:	08 95       	ret

    case 6:                 // Wuerfel Zahl 6
    LED_TASK[12][0]=1;      // Wuerfel Zahl 6 >  LED 12
 152:	81 e0       	ldi	r24, 0x01	; 1
 154:	80 93 91 01 	sts	0x0191, r24
    LED_TASK[13][0]=1;      // Wuerfel Zahl 6 >  LED 13
 158:	80 93 93 01 	sts	0x0193, r24
    LED_TASK[14][0]=1;      // Wuerfel Zahl 6 >  LED 14
 15c:	80 93 95 01 	sts	0x0195, r24
    LED_TASK[15][0]=1;      // Wuerfel Zahl 6 >  LED 15
 160:	80 93 97 01 	sts	0x0197, r24
    LED_TASK[16][0]=1;      // Wuerfel Zahl 6 >  LED 16
 164:	80 93 99 01 	sts	0x0199, r24
    LED_TASK[17][0]=1;      // Wuerfel Zahl 6 >  LED 17
 168:	80 93 9b 01 	sts	0x019B, r24
    break;                  // Ende case
 16c:	08 95       	ret

    case 7:                 // Wuerfel Zahl 7
    LED_TASK[11][0]=1;      // Wuerfel Zahl 7 >  LED 11
 16e:	81 e0       	ldi	r24, 0x01	; 1
 170:	80 93 8f 01 	sts	0x018F, r24
    LED_TASK[12][0]=1;      // Wuerfel Zahl 7 >  LED 12
 174:	80 93 91 01 	sts	0x0191, r24
    LED_TASK[13][0]=1;      // Wuerfel Zahl 7 >  LED 13
 178:	80 93 93 01 	sts	0x0193, r24
    LED_TASK[14][0]=1;      // Wuerfel Zahl 7 >  LED 14
 17c:	80 93 95 01 	sts	0x0195, r24
    LED_TASK[15][0]=1;      // Wuerfel Zahl 7 >  LED 15
 180:	80 93 97 01 	sts	0x0197, r24
    LED_TASK[16][0]=1;      // Wuerfel Zahl 7 >  LED 16
 184:	80 93 99 01 	sts	0x0199, r24
    LED_TASK[17][0]=1;      // Wuerfel Zahl 7 >  LED 17
 188:	80 93 9b 01 	sts	0x019B, r24
 18c:	08 95       	ret

0000018e <drehenr>:
Ansteuerung Wuerfelfeld (7 LED`s) um einen drehenden Zeiger darzustellen
Wird genutzt um eine Wuerfel Aktivitaet darzustellen
Uebergabe der Zeigerstellung 
***************************************************************************************/
void drehenr(uint8_t wstep)
{
 18e:	ef e8       	ldi	r30, 0x8F	; 143
 190:	f1 e0       	ldi	r31, 0x01	; 1
 192:	2d e9       	ldi	r18, 0x9D	; 157
 194:	31 e0       	ldi	r19, 0x01	; 1
for (uint8_t step = 11; step <= 17 ; step++)    // Abschalten aller 7 LED`s
    {
    LED_TASK[step][0]=0;                        // Abschalten aller LED`s auf dem Wuerfelfeld
 196:	10 82       	st	Z, r1
 198:	32 96       	adiw	r30, 0x02	; 2
Wird genutzt um eine Wuerfel Aktivitaet darzustellen
Uebergabe der Zeigerstellung 
***************************************************************************************/
void drehenr(uint8_t wstep)
{
for (uint8_t step = 11; step <= 17 ; step++)    // Abschalten aller 7 LED`s
 19a:	e2 17       	cp	r30, r18
 19c:	f3 07       	cpc	r31, r19
 19e:	d9 f7       	brne	.-10     	; 0x196 <drehenr+0x8>
    {
    LED_TASK[step][0]=0;                        // Abschalten aller LED`s auf dem Wuerfelfeld
    }
switch (wstep)
 1a0:	83 30       	cpi	r24, 0x03	; 3
 1a2:	e1 f0       	breq	.+56     	; 0x1dc <drehenr+0x4e>
 1a4:	28 f4       	brcc	.+10     	; 0x1b0 <drehenr+0x22>
 1a6:	81 30       	cpi	r24, 0x01	; 1
 1a8:	49 f0       	breq	.+18     	; 0x1bc <drehenr+0x2e>
 1aa:	82 30       	cpi	r24, 0x02	; 2
 1ac:	79 f0       	breq	.+30     	; 0x1cc <drehenr+0x3e>
 1ae:	08 95       	ret
 1b0:	85 30       	cpi	r24, 0x05	; 5
 1b2:	21 f1       	breq	.+72     	; 0x1fc <drehenr+0x6e>
 1b4:	d8 f0       	brcs	.+54     	; 0x1ec <drehenr+0x5e>
 1b6:	86 30       	cpi	r24, 0x06	; 6
 1b8:	49 f1       	breq	.+82     	; 0x20c <drehenr+0x7e>
 1ba:	08 95       	ret
    {
    case 1:                 // Step 1 -
    LED_TASK[11][0]=1;      // LED 11
 1bc:	81 e0       	ldi	r24, 0x01	; 1
 1be:	80 93 8f 01 	sts	0x018F, r24
    LED_TASK[12][0]=1;      // LED 12
 1c2:	80 93 91 01 	sts	0x0191, r24
    LED_TASK[13][0]=1;      // LED 13
 1c6:	80 93 93 01 	sts	0x0193, r24
    break;                  // Ende case
 1ca:	08 95       	ret

    case 2:                 // Step 2 nr
    LED_TASK[11][0]=1;      // LED 11
 1cc:	81 e0       	ldi	r24, 0x01	; 1
 1ce:	80 93 8f 01 	sts	0x018F, r24
    LED_TASK[15][0]=1;      // LED 15
 1d2:	80 93 97 01 	sts	0x0197, r24
    LED_TASK[17][0]=1;      // LED 17
 1d6:	80 93 9b 01 	sts	0x019B, r24
    break;                  // Ende case
 1da:	08 95       	ret

    case 3:                 // Step 3 /
    LED_TASK[11][0]=1;      // LED 11
 1dc:	81 e0       	ldi	r24, 0x01	; 1
 1de:	80 93 8f 01 	sts	0x018F, r24
    LED_TASK[14][0]=1;      // LED 14
 1e2:	80 93 95 01 	sts	0x0195, r24
    LED_TASK[16][0]=1;      // LED 16
 1e6:	80 93 99 01 	sts	0x0199, r24
    break;                  // Ende case
 1ea:	08 95       	ret

    case 4:                 // Step 4 -
    LED_TASK[11][0]=1;      // LED 11
 1ec:	81 e0       	ldi	r24, 0x01	; 1
 1ee:	80 93 8f 01 	sts	0x018F, r24
    LED_TASK[12][0]=1;      // LED 12
 1f2:	80 93 91 01 	sts	0x0191, r24
    LED_TASK[13][0]=1;      // LED 13
 1f6:	80 93 93 01 	sts	0x0193, r24
    break;                  // Ende case
 1fa:	08 95       	ret

    case 5:                 // Step 5 nr
    LED_TASK[11][0]=1;      // LED 11
 1fc:	81 e0       	ldi	r24, 0x01	; 1
 1fe:	80 93 8f 01 	sts	0x018F, r24
    LED_TASK[15][0]=1;      // LED 15
 202:	80 93 97 01 	sts	0x0197, r24
    LED_TASK[17][0]=1;      // LED 17
 206:	80 93 9b 01 	sts	0x019B, r24
    break;                  // Ende case
 20a:	08 95       	ret

    case 6:                 // Step 6 /
    LED_TASK[11][0]=1;      // LED 11
 20c:	81 e0       	ldi	r24, 0x01	; 1
 20e:	80 93 8f 01 	sts	0x018F, r24
    LED_TASK[14][0]=1;      // LED 14
 212:	80 93 95 01 	sts	0x0195, r24
    LED_TASK[16][0]=1;      // LED 16
 216:	80 93 99 01 	sts	0x0199, r24
 21a:	08 95       	ret

0000021c <ledband>:
/******************************************************************************
Ansteuerung LED Band auf Basis AD Wandler
******************************************************************************/

void ledband(uint16_t tempwert, uint16_t tempset)
{
 21c:	cf 93       	push	r28
if ( tempwert < tempset)
 21e:	86 17       	cp	r24, r22
 220:	97 07       	cpc	r25, r23
 222:	f0 f4       	brcc	.+60     	; 0x260 <ledband+0x44>
 224:	eb e7       	ldi	r30, 0x7B	; 123
 226:	f1 e0       	ldi	r31, 0x01	; 1
 228:	2f e8       	ldi	r18, 0x8F	; 143
 22a:	31 e0       	ldi	r19, 0x01	; 1
    {
    for (uint8_t step = 0; step <= 9 ; step++)  // Fuer Testzwecke werden die Daten als Binaere Zahl auf die LED`s 1 bis 10 geschrieben.
        {
        LED_TASK[step+1][0]=0;                  // Abschalten aller LED`s der Temperaturanzeige
 22c:	10 82       	st	Z, r1
 22e:	32 96       	adiw	r30, 0x02	; 2

void ledband(uint16_t tempwert, uint16_t tempset)
{
if ( tempwert < tempset)
    {
    for (uint8_t step = 0; step <= 9 ; step++)  // Fuer Testzwecke werden die Daten als Binaere Zahl auf die LED`s 1 bis 10 geschrieben.
 230:	e2 17       	cp	r30, r18
 232:	f3 07       	cpc	r31, r19
 234:	d9 f7       	brne	.-10     	; 0x22c <ledband+0x10>
 236:	14 c0       	rjmp	.+40     	; 0x260 <ledband+0x44>
 238:	9a 01       	movw	r18, r20
 23a:	2e 0f       	add	r18, r30
 23c:	3f 1f       	adc	r19, r31


for (uint8_t step = 0; step <= 9 ; step++)      // Zur Ansteuerung des LED Temperaturbandes
    {
    tempset++; //
    if ( (tempwert >= tempset) && (tempwert <= (tempset + 2)) ) // Hier wird festgelegt in welchen Bereich die LED's zugeschaltet werden.
 23e:	82 17       	cp	r24, r18
 240:	93 07       	cpc	r25, r19
 242:	40 f0       	brcs	.+16     	; 0x254 <ledband+0x38>
 244:	9b 01       	movw	r18, r22
 246:	2e 0f       	add	r18, r30
 248:	3f 1f       	adc	r19, r31
 24a:	28 17       	cp	r18, r24
 24c:	39 07       	cpc	r19, r25
 24e:	10 f0       	brcs	.+4      	; 0x254 <ledband+0x38>
        {
        LED_TASK[step+1][0]=1;                  // Zuschalten LED auf den Band
 250:	c0 83       	st	Z, r28
 252:	01 c0       	rjmp	.+2      	; 0x256 <ledband+0x3a>
        }
    else
        {
        LED_TASK[step+1][0]=0;                  // Abschalten der nichtaktiven LED auf den Band
 254:	10 82       	st	Z, r1
 256:	32 96       	adiw	r30, 0x02	; 2
        }
    }



for (uint8_t step = 0; step <= 9 ; step++)      // Zur Ansteuerung des LED Temperaturbandes
 258:	ea 17       	cp	r30, r26
 25a:	fb 07       	cpc	r31, r27
 25c:	69 f7       	brne	.-38     	; 0x238 <ledband+0x1c>
 25e:	11 c0       	rjmp	.+34     	; 0x282 <ledband+0x66>
 260:	eb e7       	ldi	r30, 0x7B	; 123
 262:	f1 e0       	ldi	r31, 0x01	; 1
 264:	29 e7       	ldi	r18, 0x79	; 121
 266:	31 e0       	ldi	r19, 0x01	; 1
 268:	af e8       	ldi	r26, 0x8F	; 143
 26a:	b1 e0       	ldi	r27, 0x01	; 1
 26c:	a9 01       	movw	r20, r18
 26e:	40 95       	com	r20
 270:	50 95       	com	r21
 272:	46 0f       	add	r20, r22
 274:	57 1f       	adc	r21, r23
 276:	62 1b       	sub	r22, r18
 278:	73 0b       	sbc	r23, r19
 27a:	6f 5f       	subi	r22, 0xFF	; 255
 27c:	7f 4f       	sbci	r23, 0xFF	; 255
    {
    tempset++; //
    if ( (tempwert >= tempset) && (tempwert <= (tempset + 2)) ) // Hier wird festgelegt in welchen Bereich die LED's zugeschaltet werden.
        {
        LED_TASK[step+1][0]=1;                  // Zuschalten LED auf den Band
 27e:	c1 e0       	ldi	r28, 0x01	; 1
 280:	db cf       	rjmp	.-74     	; 0x238 <ledband+0x1c>
    tempset++;
    }



}
 282:	cf 91       	pop	r28
 284:	08 95       	ret

00000286 <zeilenwahl>:
Das Timing wird per Timer Interrupt gesteuert
******************************************************************************/
void zeilenwahl(uint8_t zeile)
{

 switch (zeile)
 286:	90 e0       	ldi	r25, 0x00	; 0
 288:	fc 01       	movw	r30, r24
 28a:	31 97       	sbiw	r30, 0x01	; 1
 28c:	e3 31       	cpi	r30, 0x13	; 19
 28e:	f1 05       	cpc	r31, r1
 290:	08 f0       	brcs	.+2      	; 0x294 <zeilenwahl+0xe>
 292:	c2 c0       	rjmp	.+388    	; 0x418 <zeilenwahl+0x192>
 294:	e5 5c       	subi	r30, 0xC5	; 197
 296:	ff 4f       	sbci	r31, 0xFF	; 255
 298:	0c 94 ed 04 	jmp	0x9da	; 0x9da <__tablejump2__>
    {
     case 1:
     ZEILE1_ON;     // LED1 AN
 29c:	22 9a       	sbi	0x04, 2	; 4
     ZEILE2_OFF;
 29e:	21 98       	cbi	0x04, 1	; 4
     ZEILE3_OFF;
 2a0:	20 98       	cbi	0x04, 0	; 4
     ZEILE4_OFF;
 2a2:	57 98       	cbi	0x0a, 7	; 10
     SPALTE1_ON;
 2a4:	5e 9a       	sbi	0x0b, 6	; 11
     SPALTE2_OFF;
 2a6:	5d 98       	cbi	0x0b, 5	; 11
     SPALTE3_OFF;
 2a8:	5c 98       	cbi	0x0b, 4	; 11
     SPALTE4_OFF;
 2aa:	5b 98       	cbi	0x0b, 3	; 11
     SPALTE5_OFF;
 2ac:	5a 98       	cbi	0x0b, 2	; 11
     break;
 2ae:	08 95       	ret
     case 2:
     ZEILE1_ON;     // LED2 AN
 2b0:	22 9a       	sbi	0x04, 2	; 4
     ZEILE2_OFF;
 2b2:	21 98       	cbi	0x04, 1	; 4
     ZEILE3_OFF;
 2b4:	20 98       	cbi	0x04, 0	; 4
     ZEILE4_OFF;
 2b6:	57 98       	cbi	0x0a, 7	; 10
     SPALTE1_OFF;
 2b8:	5e 98       	cbi	0x0b, 6	; 11
     SPALTE2_ON;
 2ba:	5d 9a       	sbi	0x0b, 5	; 11
     SPALTE3_OFF;
 2bc:	5c 98       	cbi	0x0b, 4	; 11
     SPALTE4_OFF;
 2be:	5b 98       	cbi	0x0b, 3	; 11
     SPALTE5_OFF;
 2c0:	5a 98       	cbi	0x0b, 2	; 11
     break;
 2c2:	08 95       	ret
     case 3:
      ZEILE1_ON;        // LED3 AN
 2c4:	22 9a       	sbi	0x04, 2	; 4
      ZEILE2_OFF;
 2c6:	21 98       	cbi	0x04, 1	; 4
      ZEILE3_OFF;
 2c8:	20 98       	cbi	0x04, 0	; 4
      ZEILE4_OFF;
 2ca:	57 98       	cbi	0x0a, 7	; 10
      SPALTE1_OFF;
 2cc:	5e 98       	cbi	0x0b, 6	; 11
      SPALTE2_OFF;
 2ce:	5d 98       	cbi	0x0b, 5	; 11
      SPALTE3_ON;
 2d0:	5c 9a       	sbi	0x0b, 4	; 11
      SPALTE4_OFF;
 2d2:	5b 98       	cbi	0x0b, 3	; 11
      SPALTE5_OFF;
 2d4:	5a 98       	cbi	0x0b, 2	; 11
     break;
 2d6:	08 95       	ret
     case 4:
      ZEILE1_ON;        // LED4 AN
 2d8:	22 9a       	sbi	0x04, 2	; 4
      ZEILE2_OFF;
 2da:	21 98       	cbi	0x04, 1	; 4
      ZEILE3_OFF;
 2dc:	20 98       	cbi	0x04, 0	; 4
      ZEILE4_OFF;
 2de:	57 98       	cbi	0x0a, 7	; 10
      SPALTE1_OFF;
 2e0:	5e 98       	cbi	0x0b, 6	; 11
      SPALTE2_OFF;
 2e2:	5d 98       	cbi	0x0b, 5	; 11
      SPALTE3_OFF;
 2e4:	5c 98       	cbi	0x0b, 4	; 11
      SPALTE4_ON;
 2e6:	5b 9a       	sbi	0x0b, 3	; 11
      SPALTE5_OFF;
 2e8:	5a 98       	cbi	0x0b, 2	; 11
     break;
 2ea:	08 95       	ret
     case 5:
     ZEILE1_ON;     // LED5 AN
 2ec:	22 9a       	sbi	0x04, 2	; 4
     ZEILE2_OFF;
 2ee:	21 98       	cbi	0x04, 1	; 4
     ZEILE3_OFF;
 2f0:	20 98       	cbi	0x04, 0	; 4
     ZEILE4_OFF;
 2f2:	57 98       	cbi	0x0a, 7	; 10
     SPALTE1_OFF;
 2f4:	5e 98       	cbi	0x0b, 6	; 11
     SPALTE2_OFF;
 2f6:	5d 98       	cbi	0x0b, 5	; 11
     SPALTE3_OFF;
 2f8:	5c 98       	cbi	0x0b, 4	; 11
     SPALTE4_OFF;
 2fa:	5b 98       	cbi	0x0b, 3	; 11
     SPALTE5_ON;
 2fc:	5a 9a       	sbi	0x0b, 2	; 11
     break;
 2fe:	08 95       	ret
     case 6:
     ZEILE1_OFF;        // LED6 AN
 300:	22 98       	cbi	0x04, 2	; 4
     ZEILE2_ON;
 302:	21 9a       	sbi	0x04, 1	; 4
     ZEILE3_OFF;
 304:	20 98       	cbi	0x04, 0	; 4
     ZEILE4_OFF;
 306:	57 98       	cbi	0x0a, 7	; 10
     SPALTE1_ON;
 308:	5e 9a       	sbi	0x0b, 6	; 11
     SPALTE2_OFF;
 30a:	5d 98       	cbi	0x0b, 5	; 11
     SPALTE3_OFF;
 30c:	5c 98       	cbi	0x0b, 4	; 11
     SPALTE4_OFF;
 30e:	5b 98       	cbi	0x0b, 3	; 11
     SPALTE5_OFF;
 310:	5a 98       	cbi	0x0b, 2	; 11
     break;
 312:	08 95       	ret
     case 7:
     ZEILE1_OFF;        // LED7 AN
 314:	22 98       	cbi	0x04, 2	; 4
     ZEILE2_ON;
 316:	21 9a       	sbi	0x04, 1	; 4
     ZEILE3_OFF;
 318:	20 98       	cbi	0x04, 0	; 4
     ZEILE4_OFF;
 31a:	57 98       	cbi	0x0a, 7	; 10
     SPALTE1_OFF;
 31c:	5e 98       	cbi	0x0b, 6	; 11
     SPALTE2_ON;
 31e:	5d 9a       	sbi	0x0b, 5	; 11
     SPALTE3_OFF;
 320:	5c 98       	cbi	0x0b, 4	; 11
     SPALTE4_OFF;
 322:	5b 98       	cbi	0x0b, 3	; 11
     SPALTE5_OFF;
 324:	5a 98       	cbi	0x0b, 2	; 11
     break;
 326:	08 95       	ret
     case 8:
     ZEILE1_OFF;        // LED8 AN
 328:	22 98       	cbi	0x04, 2	; 4
     ZEILE2_ON;
 32a:	21 9a       	sbi	0x04, 1	; 4
     ZEILE3_OFF;
 32c:	20 98       	cbi	0x04, 0	; 4
     ZEILE4_OFF;
 32e:	57 98       	cbi	0x0a, 7	; 10
     SPALTE1_OFF;
 330:	5e 98       	cbi	0x0b, 6	; 11
     SPALTE2_OFF;
 332:	5d 98       	cbi	0x0b, 5	; 11
     SPALTE3_ON;
 334:	5c 9a       	sbi	0x0b, 4	; 11
     SPALTE4_OFF;
 336:	5b 98       	cbi	0x0b, 3	; 11
     SPALTE5_OFF;
 338:	5a 98       	cbi	0x0b, 2	; 11
     break;
 33a:	08 95       	ret
     case 9:
     ZEILE1_OFF;        // LED9 AN
 33c:	22 98       	cbi	0x04, 2	; 4
     ZEILE2_ON;
 33e:	21 9a       	sbi	0x04, 1	; 4
     ZEILE3_OFF;
 340:	20 98       	cbi	0x04, 0	; 4
     ZEILE4_OFF;
 342:	57 98       	cbi	0x0a, 7	; 10
     SPALTE1_OFF;
 344:	5e 98       	cbi	0x0b, 6	; 11
     SPALTE2_OFF;
 346:	5d 98       	cbi	0x0b, 5	; 11
     SPALTE3_OFF;
 348:	5c 98       	cbi	0x0b, 4	; 11
     SPALTE4_ON;
 34a:	5b 9a       	sbi	0x0b, 3	; 11
     SPALTE5_OFF;
 34c:	5a 98       	cbi	0x0b, 2	; 11
     break;
 34e:	08 95       	ret
     case 10:
     ZEILE1_OFF;        // LED10 AN
 350:	22 98       	cbi	0x04, 2	; 4
     ZEILE2_ON;
 352:	21 9a       	sbi	0x04, 1	; 4
     ZEILE3_OFF;
 354:	20 98       	cbi	0x04, 0	; 4
     ZEILE4_OFF;
 356:	57 98       	cbi	0x0a, 7	; 10
     SPALTE1_OFF;
 358:	5e 98       	cbi	0x0b, 6	; 11
     SPALTE2_OFF;
 35a:	5d 98       	cbi	0x0b, 5	; 11
     SPALTE3_OFF;
 35c:	5c 98       	cbi	0x0b, 4	; 11
     SPALTE4_OFF;
 35e:	5b 98       	cbi	0x0b, 3	; 11
     SPALTE5_ON;
 360:	5a 9a       	sbi	0x0b, 2	; 11
     break;
 362:	08 95       	ret
     case 11:
     ZEILE1_OFF;        // LED11 AN
 364:	22 98       	cbi	0x04, 2	; 4
     ZEILE2_OFF;
 366:	21 98       	cbi	0x04, 1	; 4
     ZEILE3_ON;
 368:	20 9a       	sbi	0x04, 0	; 4
     ZEILE4_OFF;
 36a:	57 98       	cbi	0x0a, 7	; 10
     SPALTE1_ON;
 36c:	5e 9a       	sbi	0x0b, 6	; 11
     SPALTE2_OFF;
 36e:	5d 98       	cbi	0x0b, 5	; 11
     SPALTE3_OFF;
 370:	5c 98       	cbi	0x0b, 4	; 11
     SPALTE4_OFF;
 372:	5b 98       	cbi	0x0b, 3	; 11
     SPALTE5_OFF;
 374:	5a 98       	cbi	0x0b, 2	; 11
     break;
 376:	08 95       	ret
     case 12:
     ZEILE1_OFF;        // LED12 AN
 378:	22 98       	cbi	0x04, 2	; 4
     ZEILE2_OFF;
 37a:	21 98       	cbi	0x04, 1	; 4
     ZEILE3_ON;
 37c:	20 9a       	sbi	0x04, 0	; 4
     ZEILE4_OFF;
 37e:	57 98       	cbi	0x0a, 7	; 10
     SPALTE1_OFF;
 380:	5e 98       	cbi	0x0b, 6	; 11
     SPALTE2_ON;
 382:	5d 9a       	sbi	0x0b, 5	; 11
     SPALTE3_OFF;
 384:	5c 98       	cbi	0x0b, 4	; 11
     SPALTE4_OFF;
 386:	5b 98       	cbi	0x0b, 3	; 11
     SPALTE5_OFF;
 388:	5a 98       	cbi	0x0b, 2	; 11
     break;
 38a:	08 95       	ret
     case 13:
     ZEILE1_OFF;        // LED13 AN
 38c:	22 98       	cbi	0x04, 2	; 4
     ZEILE2_OFF;
 38e:	21 98       	cbi	0x04, 1	; 4
     ZEILE3_ON;
 390:	20 9a       	sbi	0x04, 0	; 4
     ZEILE4_OFF;
 392:	57 98       	cbi	0x0a, 7	; 10
     SPALTE1_OFF;
 394:	5e 98       	cbi	0x0b, 6	; 11
     SPALTE2_OFF;
 396:	5d 98       	cbi	0x0b, 5	; 11
     SPALTE3_ON;
 398:	5c 9a       	sbi	0x0b, 4	; 11
     SPALTE4_OFF;
 39a:	5b 98       	cbi	0x0b, 3	; 11
     SPALTE5_OFF;
 39c:	5a 98       	cbi	0x0b, 2	; 11
     break;
 39e:	08 95       	ret
     case 14:
     ZEILE1_OFF;        // LED14 AN
 3a0:	22 98       	cbi	0x04, 2	; 4
     ZEILE2_OFF;
 3a2:	21 98       	cbi	0x04, 1	; 4
     ZEILE3_ON;
 3a4:	20 9a       	sbi	0x04, 0	; 4
     ZEILE4_OFF;
 3a6:	57 98       	cbi	0x0a, 7	; 10
     SPALTE1_OFF;
 3a8:	5e 98       	cbi	0x0b, 6	; 11
     SPALTE2_OFF;
 3aa:	5d 98       	cbi	0x0b, 5	; 11
     SPALTE3_OFF;
 3ac:	5c 98       	cbi	0x0b, 4	; 11
     SPALTE4_ON;
 3ae:	5b 9a       	sbi	0x0b, 3	; 11
     SPALTE5_OFF;
 3b0:	5a 98       	cbi	0x0b, 2	; 11
     break;
 3b2:	08 95       	ret
     case 15:
     ZEILE1_OFF;        // LED15 AN
 3b4:	22 98       	cbi	0x04, 2	; 4
     ZEILE2_OFF;
 3b6:	21 98       	cbi	0x04, 1	; 4
     ZEILE3_ON;
 3b8:	20 9a       	sbi	0x04, 0	; 4
     ZEILE4_OFF;
 3ba:	57 98       	cbi	0x0a, 7	; 10
     SPALTE1_OFF;
 3bc:	5e 98       	cbi	0x0b, 6	; 11
     SPALTE2_OFF;
 3be:	5d 98       	cbi	0x0b, 5	; 11
     SPALTE3_OFF;
 3c0:	5c 98       	cbi	0x0b, 4	; 11
     SPALTE4_OFF;
 3c2:	5b 98       	cbi	0x0b, 3	; 11
     SPALTE5_ON;
 3c4:	5a 9a       	sbi	0x0b, 2	; 11
     break;
 3c6:	08 95       	ret
     case 16:
     ZEILE1_OFF;        // LED16 AN
 3c8:	22 98       	cbi	0x04, 2	; 4
     ZEILE2_OFF;
 3ca:	21 98       	cbi	0x04, 1	; 4
     ZEILE3_OFF;
 3cc:	20 98       	cbi	0x04, 0	; 4
     ZEILE4_ON;
 3ce:	57 9a       	sbi	0x0a, 7	; 10
     SPALTE1_ON;
 3d0:	5e 9a       	sbi	0x0b, 6	; 11
     SPALTE2_OFF;
 3d2:	5d 98       	cbi	0x0b, 5	; 11
     SPALTE3_OFF;
 3d4:	5c 98       	cbi	0x0b, 4	; 11
     SPALTE4_OFF;
 3d6:	5b 98       	cbi	0x0b, 3	; 11
     SPALTE5_OFF;
 3d8:	5a 98       	cbi	0x0b, 2	; 11
     break;
 3da:	08 95       	ret
     case 17:
     ZEILE1_OFF;        // LED17 AN
 3dc:	22 98       	cbi	0x04, 2	; 4
     ZEILE2_OFF;
 3de:	21 98       	cbi	0x04, 1	; 4
     ZEILE3_OFF;
 3e0:	20 98       	cbi	0x04, 0	; 4
     ZEILE4_ON;
 3e2:	57 9a       	sbi	0x0a, 7	; 10
     SPALTE1_OFF;
 3e4:	5e 98       	cbi	0x0b, 6	; 11
     SPALTE2_ON;
 3e6:	5d 9a       	sbi	0x0b, 5	; 11
     SPALTE3_OFF;
 3e8:	5c 98       	cbi	0x0b, 4	; 11
     SPALTE4_OFF;
 3ea:	5b 98       	cbi	0x0b, 3	; 11
     SPALTE5_OFF;
 3ec:	5a 98       	cbi	0x0b, 2	; 11
     break;
 3ee:	08 95       	ret
     case 18:
     ZEILE1_OFF;        // LED18 AN
 3f0:	22 98       	cbi	0x04, 2	; 4
     ZEILE2_OFF;
 3f2:	21 98       	cbi	0x04, 1	; 4
     ZEILE3_OFF;
 3f4:	20 98       	cbi	0x04, 0	; 4
     ZEILE4_ON;
 3f6:	57 9a       	sbi	0x0a, 7	; 10
     SPALTE1_OFF;
 3f8:	5e 98       	cbi	0x0b, 6	; 11
     SPALTE2_OFF;
 3fa:	5d 98       	cbi	0x0b, 5	; 11
     SPALTE3_ON;
 3fc:	5c 9a       	sbi	0x0b, 4	; 11
     SPALTE4_OFF;
 3fe:	5b 98       	cbi	0x0b, 3	; 11
     SPALTE5_OFF;
 400:	5a 98       	cbi	0x0b, 2	; 11
     break;
 402:	08 95       	ret
     case 19:
     ZEILE1_OFF;        // LED19 AN
 404:	22 98       	cbi	0x04, 2	; 4
     ZEILE2_OFF;
 406:	21 98       	cbi	0x04, 1	; 4
     ZEILE3_OFF;
 408:	20 98       	cbi	0x04, 0	; 4
     ZEILE4_ON;
 40a:	57 9a       	sbi	0x0a, 7	; 10
     SPALTE1_OFF;
 40c:	5e 98       	cbi	0x0b, 6	; 11
     SPALTE2_OFF;
 40e:	5d 98       	cbi	0x0b, 5	; 11
     SPALTE3_OFF;
 410:	5c 98       	cbi	0x0b, 4	; 11
     SPALTE4_ON;
 412:	5b 9a       	sbi	0x0b, 3	; 11
     SPALTE5_OFF;
 414:	5a 98       	cbi	0x0b, 2	; 11
     break;
 416:	08 95       	ret
     default:
     ZEILE1_OFF;        // LEDs AUS
 418:	22 98       	cbi	0x04, 2	; 4
     ZEILE2_OFF;
 41a:	21 98       	cbi	0x04, 1	; 4
     ZEILE3_OFF;
 41c:	20 98       	cbi	0x04, 0	; 4
     ZEILE4_OFF;
 41e:	57 98       	cbi	0x0a, 7	; 10
     SPALTE1_OFF;
 420:	5e 98       	cbi	0x0b, 6	; 11
     SPALTE2_OFF;
 422:	5d 98       	cbi	0x0b, 5	; 11
     SPALTE3_OFF;
 424:	5c 98       	cbi	0x0b, 4	; 11
     SPALTE4_OFF;
 426:	5b 98       	cbi	0x0b, 3	; 11
     SPALTE5_OFF;
 428:	5a 98       	cbi	0x0b, 2	; 11
 42a:	08 95       	ret

0000042c <PORTs_init>:
Bei Init werden die PORTS PB0 bis PB2 als Ausgang gesetzt
und die PORTS PB3 bis PB7 als Ausgang
PULLUP Widerstaende zur Abfrage der Jumper Stellung werden im Programm gesetzt.

*/
    DDRB = 0b00000111;
 42c:	87 e0       	ldi	r24, 0x07	; 7
 42e:	84 b9       	out	0x04, r24	; 4
    PORTD =0b00000000;
 430:	1b b8       	out	0x0b, r1	; 11
PC6 = RESET
PC7 = NC
Alle Ports auf Eingang, bis auf PORT PC5 AUSGANG fuer DEBUG Ausgabe 
PULLUP Widerstand vom PORT PC2,PC4 aktive
*/
    DDRC =  0b00100000;
 432:	80 e2       	ldi	r24, 0x20	; 32
 434:	87 b9       	out	0x07, r24	; 7
    PORTC = 0b00010100;
 436:	84 e1       	ldi	r24, 0x14	; 20
 438:	88 b9       	out	0x08, r24	; 8
Port PD2 bis PD7 auf Ausgang



*/
    DDRD =  0b01111100;
 43a:	8c e7       	ldi	r24, 0x7C	; 124
 43c:	8a b9       	out	0x0a, r24	; 10
    PORTD = 0b00000000;
 43e:	1b b8       	out	0x0b, r1	; 11
 440:	08 95       	ret

00000442 <TIMER_init>:
******************************************************************************/
void TIMER_init(void)
{

/************************ TIMER 0 8 BIT Zaehler  *****************************/
    TCCR0B = 0b00000001; // Teiler 1024 3,68MHZ = 259ns*8*256(8BIT) = 0,5ms
 442:	81 e0       	ldi	r24, 0x01	; 1
 444:	85 bd       	out	0x25, r24	; 37
    TCCR0A = 0x00;
 446:	14 bc       	out	0x24, r1	; 36
    OCR0A = 0;          // Output Compare Register
 448:	17 bc       	out	0x27, r1	; 39
    OCR0B = 0;          // Output Compare Register
 44a:	18 bc       	out	0x28, r1	; 40
    TCNT0 = 0;          // counter Timer 0
 44c:	16 bc       	out	0x26, r1	; 38
    sbi(0,TIMSK0);      // Timer0 Overflow Interrupt Enable
 44e:	ee e6       	ldi	r30, 0x6E	; 110
 450:	f0 e0       	ldi	r31, 0x00	; 0
 452:	80 81       	ld	r24, Z
 454:	81 60       	ori	r24, 0x01	; 1
 456:	80 83       	st	Z, r24


/************************ TIMER 2 8 BIT Zaehler ******************************/

    //TCCR2B = 0x07;    // Teiler 1024 3,68MHZ = 259ns*1024*256(8BIT) = 67,91ms
    TCCR2B = 0x06;      // Teiler  256 3,68MHZ = 259ns* 256*256(8BIT) = 16,97ms
 458:	86 e0       	ldi	r24, 0x06	; 6
 45a:	80 93 b1 00 	sts	0x00B1, r24
    //TCCR2B = 0x05;    // Teiler  128 3,68MHZ = 259ns* 128*256(8BIT) =  8,49ms
    //TCCR2B = 0x04;    // Teiler   64 3,68MHZ =  83ns*  64*256(8BIT) =  4,248ms
    //TIMSK2 = 0x01;
    sbi(0,TIMSK2);      // Timer0 Overflow Interrupt Enable
 45e:	e0 e7       	ldi	r30, 0x70	; 112
 460:	f0 e0       	ldi	r31, 0x00	; 0
 462:	80 81       	ld	r24, Z
 464:	81 60       	ori	r24, 0x01	; 1
 466:	80 83       	st	Z, r24

/************************ Analog Digital Wandler Singel **********************/
    ADMUX = 0b11001000;  //int.	T-Sensor BIT4, Internal Reference 1,1V BIT 6&7
 468:	88 ec       	ldi	r24, 0xC8	; 200
 46a:	80 93 7c 00 	sts	0x007C, r24
    // ADC Enable BIT7, ADC Start Conversion BIT 6,ADC Auto Trigger Enable BIT 5, Vorteiler auf 32 fuer den ADC BIT 1-3
	ADCSRA = 0b10000101; 
 46e:	85 e8       	ldi	r24, 0x85	; 133
 470:	80 93 7a 00 	sts	0x007A, r24
    ADCSRB = 0b00000000; // Timer/Counter1 Overflow startet Wandlung, BIT 1&2
 474:	10 92 7b 00 	sts	0x007B, r1
 478:	08 95       	ret

0000047a <UART_init>:
Aktivieren der Betriebsart Senden und Empfangen
Aktivieren des Empfangs Interrupts 
*****************************************************************************************/
void UART_init(void)
{
    UBRR0H = HIGH(USARTSPEED);
 47a:	10 92 c5 00 	sts	0x00C5, r1
    UBRR0L = LOW(USARTSPEED);
 47e:	86 e1       	ldi	r24, 0x16	; 22
 480:	80 93 c4 00 	sts	0x00C4, r24
    UCSR0B = _BV(TXEN0) | _BV(RXEN0) | _BV(RXCIE0);
 484:	88 e9       	ldi	r24, 0x98	; 152
 486:	80 93 c1 00 	sts	0x00C1, r24
    UCSR0C = (0<<USBS0)|(3<<UCSZ00);
 48a:	86 e0       	ldi	r24, 0x06	; 6
 48c:	80 93 c2 00 	sts	0x00C2, r24
 490:	08 95       	ret

00000492 <UART_SendByte>:
/******************************************************************************
Sendet ein Byte ueber die UART
******************************************************************************/
void UART_SendByte(uint8_t data)
{
    SENDEN_AKTIV;                         // RX > TX Umschaltung 
 492:	45 9a       	sbi	0x08, 5	; 8
    rucksetzcount = 3;                    // Delay zur Rueckschaltung RX
 494:	93 e0       	ldi	r25, 0x03	; 3
 496:	90 93 77 01 	sts	0x0177, r25
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 49a:	ef ee       	ldi	r30, 0xEF	; 239
 49c:	f3 e2       	ldi	r31, 0x23	; 35
 49e:	31 97       	sbiw	r30, 0x01	; 1
 4a0:	f1 f7       	brne	.-4      	; 0x49e <UART_SendByte+0xc>
 4a2:	00 c0       	rjmp	.+0      	; 0x4a4 <UART_SendByte+0x12>
 4a4:	00 00       	nop
    _delay_ms(10);
    while(bit_is_clear(UCSR0A, UDRE0));   // wartet auf UART Ready 
 4a6:	e0 ec       	ldi	r30, 0xC0	; 192
 4a8:	f0 e0       	ldi	r31, 0x00	; 0
 4aa:	90 81       	ld	r25, Z
 4ac:	95 ff       	sbrs	r25, 5
 4ae:	fd cf       	rjmp	.-6      	; 0x4aa <UART_SendByte+0x18>
    UDR0 = data;                            
 4b0:	80 93 c6 00 	sts	0x00C6, r24
 4b4:	08 95       	ret

000004b6 <putstring>:

/******************************************************************************
sendet einen String ueber UART
******************************************************************************/
void putstring(char *s)                     
{
 4b6:	cf 93       	push	r28
 4b8:	df 93       	push	r29
 4ba:	ec 01       	movw	r28, r24
    while (*s != 0)                        
 4bc:	88 81       	ld	r24, Y
 4be:	88 23       	and	r24, r24
 4c0:	31 f0       	breq	.+12     	; 0x4ce <putstring+0x18>
 4c2:	21 96       	adiw	r28, 0x01	; 1
    {
        UART_SendByte(*s);
 4c4:	0e 94 49 02 	call	0x492	; 0x492 <UART_SendByte>
/******************************************************************************
sendet einen String ueber UART
******************************************************************************/
void putstring(char *s)                     
{
    while (*s != 0)                        
 4c8:	89 91       	ld	r24, Y+
 4ca:	81 11       	cpse	r24, r1
 4cc:	fb cf       	rjmp	.-10     	; 0x4c4 <putstring+0xe>
    {
        UART_SendByte(*s);
        *s++;
    }
}
 4ce:	df 91       	pop	r29
 4d0:	cf 91       	pop	r28
 4d2:	08 95       	ret

000004d4 <errorcodeu>:

/******************************************************************************
sendet den Fehlercode (Wandlung Hexzahl >> ASCII)
******************************************************************************/
void errorcodeu(uint8_t zahl)
{
 4d4:	cf 93       	push	r28
    uint8_t temp = 0;

    temp = zahl % 10;                       // niederwertigste Ziffer
 4d6:	2d ec       	ldi	r18, 0xCD	; 205
 4d8:	82 9f       	mul	r24, r18
 4da:	21 2d       	mov	r18, r1
 4dc:	11 24       	eor	r1, r1
 4de:	26 95       	lsr	r18
 4e0:	26 95       	lsr	r18
 4e2:	26 95       	lsr	r18
 4e4:	22 0f       	add	r18, r18
 4e6:	92 2f       	mov	r25, r18
 4e8:	99 0f       	add	r25, r25
 4ea:	99 0f       	add	r25, r25
 4ec:	29 0f       	add	r18, r25
 4ee:	98 2f       	mov	r25, r24
 4f0:	92 1b       	sub	r25, r18
 4f2:	29 2f       	mov	r18, r25
    zahl = (zahl - temp) / 10;              // Rest von 10 ergibt die Einer
 4f4:	90 e0       	ldi	r25, 0x00	; 0
 4f6:	82 1b       	sub	r24, r18
 4f8:	91 09       	sbc	r25, r1
 4fa:	6a e0       	ldi	r22, 0x0A	; 10
 4fc:	70 e0       	ldi	r23, 0x00	; 0
 4fe:	0e 94 d9 04 	call	0x9b2	; 0x9b2 <__divmodhi4>
    temp = temp | 0x30;                     // Erzeuge ASCII Zeichen
 502:	c2 2f       	mov	r28, r18
 504:	c0 63       	ori	r28, 0x30	; 48
    if(zahl != 0){  errorcodeu(zahl);   }   
 506:	66 23       	and	r22, r22
 508:	19 f0       	breq	.+6      	; 0x510 <__stack+0x11>
 50a:	86 2f       	mov	r24, r22
 50c:	0e 94 6a 02 	call	0x4d4	; 0x4d4 <errorcodeu>

    UART_SendByte(temp);                    // Sendet Ziffer
 510:	8c 2f       	mov	r24, r28
 512:	0e 94 49 02 	call	0x492	; 0x492 <UART_SendByte>
}
 516:	cf 91       	pop	r28
 518:	08 95       	ret

0000051a <wuerfellos>:
 

Die Variable wzeiger bestimmt die Geschwindigkeit und wird im Timer2 hochgezaehlt
******************************************************************************/
void wuerfellos(uint8_t drehg,uint8_t ztemp)
{
 51a:	cf 93       	push	r28
 51c:	c6 2f       	mov	r28, r22
	if (qbi (drehg,wzeiger))
 51e:	40 91 aa 02 	lds	r20, 0x02AA
 522:	50 91 ab 02 	lds	r21, 0x02AB
 526:	21 e0       	ldi	r18, 0x01	; 1
 528:	30 e0       	ldi	r19, 0x00	; 0
 52a:	08 2e       	mov	r0, r24
 52c:	02 c0       	rjmp	.+4      	; 0x532 <wuerfellos+0x18>
 52e:	22 0f       	add	r18, r18
 530:	33 1f       	adc	r19, r19
 532:	0a 94       	dec	r0
 534:	e2 f7       	brpl	.-8      	; 0x52e <wuerfellos+0x14>
 536:	24 23       	and	r18, r20
 538:	35 23       	and	r19, r21
 53a:	02 c0       	rjmp	.+4      	; 0x540 <wuerfellos+0x26>
 53c:	36 95       	lsr	r19
 53e:	27 95       	ror	r18
 540:	8a 95       	dec	r24
 542:	e2 f7       	brpl	.-8      	; 0x53c <wuerfellos+0x22>
 544:	23 2b       	or	r18, r19
 546:	c9 f0       	breq	.+50     	; 0x57a <wuerfellos+0x60>
	{
		wzeiger = 0;
 548:	10 92 ab 02 	sts	0x02AB, r1
 54c:	10 92 aa 02 	sts	0x02AA, r1
		drehenr(drehcounter);
 550:	80 91 a3 01 	lds	r24, 0x01A3
 554:	0e 94 c7 00 	call	0x18e	; 0x18e <drehenr>
		drehcounter++;
 558:	80 91 a3 01 	lds	r24, 0x01A3
 55c:	8f 5f       	subi	r24, 0xFF	; 255
 55e:	80 93 a3 01 	sts	0x01A3, r24
		if (drehcounter >= 7)
 562:	80 91 a3 01 	lds	r24, 0x01A3
 566:	87 30       	cpi	r24, 0x07	; 7
 568:	40 f0       	brcs	.+16     	; 0x57a <wuerfellos+0x60>
		{
			drehcounter = 1;
 56a:	81 e0       	ldi	r24, 0x01	; 1
 56c:	80 93 a3 01 	sts	0x01A3, r24
			drehaktiv--;
 570:	80 91 ad 02 	lds	r24, 0x02AD
 574:	81 50       	subi	r24, 0x01	; 1
 576:	80 93 ad 02 	sts	0x02AD, r24
		}
	}
	if (!drehaktiv)
 57a:	90 91 ad 02 	lds	r25, 0x02AD
 57e:	91 11       	cpse	r25, r1
 580:	06 c0       	rjmp	.+12     	; 0x58e <wuerfellos+0x74>
	{
		wuerfel(ztemp);
 582:	8c 2f       	mov	r24, r28
 584:	0e 94 6d 00 	call	0xda	; 0xda <wuerfel>
		errorcodeu(ztemp);              // Ausgabe Zufallszahl
 588:	8c 2f       	mov	r24, r28
 58a:	0e 94 6a 02 	call	0x4d4	; 0x4d4 <errorcodeu>
	}
}
 58e:	cf 91       	pop	r28
 590:	08 95       	ret

00000592 <usart_getc_intr>:
                        4 - CRC


******************************************************************************/
void usart_getc_intr(void)
{
 592:	cf 93       	push	r28
uint8_t schreibzeigernew;

// Berechnung: Anzahl der Zeichen, wieviel sich im UART Buffer befinden
// Kontrolle ob Uebertrag ausgeloesst wurde

    if(lesezeiger > schreibzeiger)                                          // Pruefung Uebertrag
 594:	80 91 75 01 	lds	r24, 0x0175
 598:	30 91 68 01 	lds	r19, 0x0168
 59c:	38 17       	cp	r19, r24
 59e:	08 f4       	brcc	.+2      	; 0x5a2 <usart_getc_intr+0x10>
        {
        schreibzeigernew = PUFFER_GROESSE + schreibzeiger;                  // Uebertrag wird dazugerechnet
 5a0:	36 50       	subi	r19, 0x06	; 6
        {
        schreibzeigernew = schreibzeiger;                                   // Keine Korrektur notwendig
        }


    zeicheninbuffer = schreibzeigernew - lesezeiger;                        // Berechnung Anzahl der Zeichen(im UART Buffer)
 5a2:	38 1b       	sub	r19, r24
 5a4:	30 93 66 01 	sts	0x0166, r19
if ( zeicheninbuffer > ( PUFFER_GROESSE - 20) )
    {
    //putstring("[ERR_BUF_OVERFLOW]");                                        // Error fuer Buffer Overflow !!!
    }

if(zeicheninbuffer && !qbi(CONTROLLWORD_VOLL,UFLAGS))                       // Wenn Zeichen im Buffer und Controllbuffer nicht gesperrt ist erfolgt Abarbeitung
 5a8:	33 23       	and	r19, r19
 5aa:	09 f4       	brne	.+2      	; 0x5ae <usart_getc_intr+0x1c>
 5ac:	4b c0       	rjmp	.+150    	; 0x644 <usart_getc_intr+0xb2>
 5ae:	50 91 ac 02 	lds	r21, 0x02AC
 5b2:	50 fd       	sbrc	r21, 0
 5b4:	47 c0       	rjmp	.+142    	; 0x644 <usart_getc_intr+0xb2>
 5b6:	20 91 75 01 	lds	r18, 0x0175
 5ba:	80 91 69 01 	lds	r24, 0x0169
 5be:	90 91 6a 01 	lds	r25, 0x016A
 5c2:	31 50       	subi	r19, 0x01	; 1
        if(puffer[lesezeiger] == STEUERZEICHEN)                             // hier befindet sich das Steuerzeichen zum ruecksetzen des Zeigers
            {
            UARTINDEX = CLEAR;                                              // das Zeichen > setzt den INDEX vom Controllword auf 0 zurueck
            }

        if( (UARTINDEX >= 0) && (UARTINDEX < CW_SIZE) )                     // nur wenn sich der INDEX zwischen 0 und Buffergroeße befindet
 5c4:	c0 e0       	ldi	r28, 0x00	; 0
 5c6:	70 e0       	ldi	r23, 0x00	; 0
            {
            CONTROLLWORD[UARTINDEX] = puffer[lesezeiger];                   // wird das aktuelle Zeichen im Buffer ins Controllword geschrieben
            UARTINDEX++;                                                    // INDEX wird um eins erhoeht
            }

        if( (UARTINDEX == CW_SIZE) && (CONTROLLWORD[0] == STEUERZEICHEN) )  // Wenn Controllword gefuellt, wird geprueft ob es sich beim ersten Zeichen um das Steuerzeichen handelt
 5c8:	ae e9       	ldi	r26, 0x9E	; 158
 5ca:	b2 e0       	ldi	r27, 0x02	; 2
            sbi(CONTROLLWORD_VOLL,UFLAGS);                                  // wenn beide Bedingung erfuellt, wird Controllword fuer Weiterbearbeitung freigegeben und gleichzeitig fuers beschreiben gesperrt
            CONTROLLWORD[0] = 0;                                            // Controllword "0" loeschen
            }
        lesezeiger++;                                                       // Lesezeiger um eins erhoehen
        zeicheninbuffer--;                                                  // Da keine Neuberechnung in der Schleife fuer die Anzahl der Zeichen im UART Buffer erfolgt wird manuell eins runtergezaehlt
        if(lesezeiger==PUFFER_GROESSE) lesezeiger=0;                        // wenn Lesepuffer am Ende ruecksetzen
 5cc:	60 e0       	ldi	r22, 0x00	; 0
if(zeicheninbuffer && !qbi(CONTROLLWORD_VOLL,UFLAGS))                       // Wenn Zeichen im Buffer und Controllbuffer nicht gesperrt ist erfolgt Abarbeitung
    {
    do
        {

        if(puffer[lesezeiger] == STEUERZEICHEN)                             // hier befindet sich das Steuerzeichen zum ruecksetzen des Zeigers
 5ce:	e2 2f       	mov	r30, r18
 5d0:	f0 e0       	ldi	r31, 0x00	; 0
 5d2:	ec 55       	subi	r30, 0x5C	; 92
 5d4:	fe 4f       	sbci	r31, 0xFE	; 254
 5d6:	40 81       	ld	r20, Z
 5d8:	4e 33       	cpi	r20, 0x3E	; 62
 5da:	21 f0       	breq	.+8      	; 0x5e4 <usart_getc_intr+0x52>
            {
            UARTINDEX = CLEAR;                                              // das Zeichen > setzt den INDEX vom Controllword auf 0 zurueck
            }

        if( (UARTINDEX >= 0) && (UARTINDEX < CW_SIZE) )                     // nur wenn sich der INDEX zwischen 0 und Buffergroeße befindet
 5dc:	85 30       	cpi	r24, 0x05	; 5
 5de:	91 05       	cpc	r25, r1
 5e0:	40 f4       	brcc	.+16     	; 0x5f2 <usart_getc_intr+0x60>
 5e2:	02 c0       	rjmp	.+4      	; 0x5e8 <usart_getc_intr+0x56>
 5e4:	8c 2f       	mov	r24, r28
 5e6:	97 2f       	mov	r25, r23
            {
            CONTROLLWORD[UARTINDEX] = puffer[lesezeiger];                   // wird das aktuelle Zeichen im Buffer ins Controllword geschrieben
 5e8:	fc 01       	movw	r30, r24
 5ea:	e2 56       	subi	r30, 0x62	; 98
 5ec:	fd 4f       	sbci	r31, 0xFD	; 253
 5ee:	40 83       	st	Z, r20
            UARTINDEX++;                                                    // INDEX wird um eins erhoeht
 5f0:	01 96       	adiw	r24, 0x01	; 1
            }

        if( (UARTINDEX == CW_SIZE) && (CONTROLLWORD[0] == STEUERZEICHEN) )  // Wenn Controllword gefuellt, wird geprueft ob es sich beim ersten Zeichen um das Steuerzeichen handelt
 5f2:	85 30       	cpi	r24, 0x05	; 5
 5f4:	91 05       	cpc	r25, r1
 5f6:	29 f4       	brne	.+10     	; 0x602 <usart_getc_intr+0x70>
 5f8:	4c 91       	ld	r20, X
 5fa:	4e 33       	cpi	r20, 0x3E	; 62
 5fc:	11 f4       	brne	.+4      	; 0x602 <usart_getc_intr+0x70>
            {
            sbi(CONTROLLWORD_VOLL,UFLAGS);                                  // wenn beide Bedingung erfuellt, wird Controllword fuer Weiterbearbeitung freigegeben und gleichzeitig fuers beschreiben gesperrt
            CONTROLLWORD[0] = 0;                                            // Controllword "0" loeschen
 5fe:	1c 92       	st	X, r1
            UARTINDEX++;                                                    // INDEX wird um eins erhoeht
            }

        if( (UARTINDEX == CW_SIZE) && (CONTROLLWORD[0] == STEUERZEICHEN) )  // Wenn Controllword gefuellt, wird geprueft ob es sich beim ersten Zeichen um das Steuerzeichen handelt
            {
            sbi(CONTROLLWORD_VOLL,UFLAGS);                                  // wenn beide Bedingung erfuellt, wird Controllword fuer Weiterbearbeitung freigegeben und gleichzeitig fuers beschreiben gesperrt
 600:	51 60       	ori	r21, 0x01	; 1
            CONTROLLWORD[0] = 0;                                            // Controllword "0" loeschen
            }
        lesezeiger++;                                                       // Lesezeiger um eins erhoehen
 602:	2f 5f       	subi	r18, 0xFF	; 255
        zeicheninbuffer--;                                                  // Da keine Neuberechnung in der Schleife fuer die Anzahl der Zeichen im UART Buffer erfolgt wird manuell eins runtergezaehlt
        if(lesezeiger==PUFFER_GROESSE) lesezeiger=0;                        // wenn Lesepuffer am Ende ruecksetzen
 604:	2a 3f       	cpi	r18, 0xFA	; 250
 606:	09 f4       	brne	.+2      	; 0x60a <usart_getc_intr+0x78>
 608:	26 2f       	mov	r18, r22
        }while(zeicheninbuffer && !qbi(CONTROLLWORD_VOLL,UFLAGS));          // wenn keine Zeichen mehr im UART Buffer sind oder das Controllword gesperrt wurde wird Schleife verlassen
 60a:	31 11       	cpse	r19, r1
 60c:	0b c0       	rjmp	.+22     	; 0x624 <usart_getc_intr+0x92>
 60e:	20 93 75 01 	sts	0x0175, r18
 612:	90 93 6a 01 	sts	0x016A, r25
 616:	80 93 69 01 	sts	0x0169, r24
 61a:	50 93 ac 02 	sts	0x02AC, r21
 61e:	30 93 66 01 	sts	0x0166, r19
 622:	10 c0       	rjmp	.+32     	; 0x644 <usart_getc_intr+0xb2>
 624:	4f ef       	ldi	r20, 0xFF	; 255
 626:	43 0f       	add	r20, r19
 628:	50 fd       	sbrc	r21, 0
 62a:	02 c0       	rjmp	.+4      	; 0x630 <usart_getc_intr+0x9e>
 62c:	34 2f       	mov	r19, r20
 62e:	cf cf       	rjmp	.-98     	; 0x5ce <usart_getc_intr+0x3c>
 630:	20 93 75 01 	sts	0x0175, r18
 634:	90 93 6a 01 	sts	0x016A, r25
 638:	80 93 69 01 	sts	0x0169, r24
 63c:	50 93 ac 02 	sts	0x02AC, r21
 640:	30 93 66 01 	sts	0x0166, r19

    }

}
 644:	cf 91       	pop	r28
 646:	08 95       	ret

00000648 <main>:

int main(void)
{
    uint8_t  templ = 0,temph = 0;
    uint16_t temperaturdaten = 0;
    LED_HELLIGKEIT = 0;
 648:	10 92 78 01 	sts	0x0178, r1
	drehcounter = 0;
 64c:	10 92 a3 01 	sts	0x01A3, r1
    PORTs_init();                       // Init der Ein und Ausgabeports
 650:	0e 94 16 02 	call	0x42c	; 0x42c <PORTs_init>
    TIMER_init();                       // Timer Init
 654:	0e 94 21 02 	call	0x442	; 0x442 <TIMER_init>
    UART_init();                        // INIT 485
 658:	0e 94 3d 02 	call	0x47a	; 0x47a <UART_init>
    sei();                              // INTERRUPTS GLOBAL AN
 65c:	78 94       	sei
	LED_TASK[1][0]=1;					// LED 1 AN nach INIT
 65e:	81 e0       	ldi	r24, 0x01	; 1
 660:	80 93 7b 01 	sts	0x017B, r24
            LED_TASK[step][0]=1;

    }
    */
    
	putstring("Tempanzeige und Wuerfel Ver 0.2");         // Ausgabe Versionstext Text
 664:	80 e0       	ldi	r24, 0x00	; 0
 666:	91 e0       	ldi	r25, 0x01	; 1
 668:	0e 94 5b 02 	call	0x4b6	; 0x4b6 <putstring>


int main(void)
{
    uint8_t  templ = 0,temph = 0;
    uint16_t temperaturdaten = 0;
 66c:	c1 2c       	mov	r12, r1
 66e:	d1 2c       	mov	r13, r1

        usart_getc_intr();                      // CHECK und Verarbeitung des UART Buffers
        if(qbi(CONTROLLWORD_VOLL,UFLAGS))       // Daten im Puffer > Run
            {
            cbi(CONTROLLWORD_VOLL,UFLAGS);      // Clear FLAG "RUN"
            if(CONTROLLWORD[1] == ADR485)       // Check Richtige Adresse
 670:	0f 2e       	mov	r0, r31
 672:	ff e9       	ldi	r31, 0x9F	; 159
 674:	ef 2e       	mov	r14, r31
 676:	f2 e0       	ldi	r31, 0x02	; 2
 678:	ff 2e       	mov	r15, r31
 67a:	f0 2d       	mov	r31, r0
                {
                switch(CONTROLLWORD[2])         // Abarbeitung switch
 67c:	0f 2e       	mov	r0, r31
 67e:	f0 ea       	ldi	r31, 0xA0	; 160
 680:	4f 2e       	mov	r4, r31
 682:	f2 e0       	ldi	r31, 0x02	; 2
 684:	5f 2e       	mov	r5, r31
 686:	f0 2d       	mov	r31, r0
                        drehenr(CONTROLLWORD[3]);		// DEBUG
                        }
                    break; //END CASE1

                    case 2:               
                    if(CONTROLLWORD[4] == ADR485)       // CRC CHECK
 688:	0f 2e       	mov	r0, r31
 68a:	f2 ea       	ldi	r31, 0xA2	; 162
 68c:	2f 2e       	mov	r2, r31
 68e:	f2 e0       	ldi	r31, 0x02	; 2
 690:	3f 2e       	mov	r3, r31
 692:	f0 2d       	mov	r31, r0
 startet den Analogdigitalwandler
 zum Auslesen des int Temp Sensor                                                                    
******************************************************************************/
         if (counter == 20)
              {
              sbi(6,ADCSRA);
 694:	0a e7       	ldi	r16, 0x7A	; 122
 696:	10 e0       	ldi	r17, 0x00	; 0
/******************************************************************************
Auslesen der Temperaturdaten aus den AD Wandler
******************************************************************************/
         if (counter == 70 )
              {
	          templ = ADCL;
 698:	0f 2e       	mov	r0, r31
 69a:	f8 e7       	ldi	r31, 0x78	; 120
 69c:	af 2e       	mov	r10, r31
 69e:	b1 2c       	mov	r11, r1
 6a0:	f0 2d       	mov	r31, r0
	          temph = ADCH;
 6a2:	0f 2e       	mov	r0, r31
 6a4:	f9 e7       	ldi	r31, 0x79	; 121
 6a6:	8f 2e       	mov	r8, r31
 6a8:	91 2c       	mov	r9, r1
 6aa:	f0 2d       	mov	r31, r0
 6ac:	0f 2e       	mov	r0, r31
 6ae:	f9 e7       	ldi	r31, 0x79	; 121
 6b0:	6f 2e       	mov	r6, r31
 6b2:	f1 e0       	ldi	r31, 0x01	; 1
 6b4:	7f 2e       	mov	r7, r31
 6b6:	f0 2d       	mov	r31, r0
 6b8:	cf e8       	ldi	r28, 0x8F	; 143
 6ba:	d1 e0       	ldi	r29, 0x01	; 1
	putstring("Tempanzeige und Wuerfel Ver 0.2");         // Ausgabe Versionstext Text
	
    while(1)
    {

        usart_getc_intr();                      // CHECK und Verarbeitung des UART Buffers
 6bc:	0e 94 c9 02 	call	0x592	; 0x592 <usart_getc_intr>
        if(qbi(CONTROLLWORD_VOLL,UFLAGS))       // Daten im Puffer > Run
 6c0:	80 91 ac 02 	lds	r24, 0x02AC
 6c4:	80 ff       	sbrs	r24, 0
 6c6:	70 c0       	rjmp	.+224    	; 0x7a8 <main+0x160>
            {
            cbi(CONTROLLWORD_VOLL,UFLAGS);      // Clear FLAG "RUN"
 6c8:	8e 7f       	andi	r24, 0xFE	; 254
 6ca:	80 93 ac 02 	sts	0x02AC, r24
            if(CONTROLLWORD[1] == ADR485)       // Check Richtige Adresse
 6ce:	f7 01       	movw	r30, r14
 6d0:	80 81       	ld	r24, Z
 6d2:	8d 30       	cpi	r24, 0x0D	; 13
 6d4:	09 f0       	breq	.+2      	; 0x6d8 <main+0x90>
 6d6:	68 c0       	rjmp	.+208    	; 0x7a8 <main+0x160>
                {
                switch(CONTROLLWORD[2])         // Abarbeitung switch
 6d8:	f2 01       	movw	r30, r4
 6da:	80 81       	ld	r24, Z
 6dc:	82 30       	cpi	r24, 0x02	; 2
 6de:	81 f1       	breq	.+96     	; 0x740 <main+0xf8>
 6e0:	28 f4       	brcc	.+10     	; 0x6ec <main+0xa4>
 6e2:	88 23       	and	r24, r24
 6e4:	49 f0       	breq	.+18     	; 0x6f8 <main+0xb0>
 6e6:	81 30       	cpi	r24, 0x01	; 1
 6e8:	a1 f0       	breq	.+40     	; 0x712 <main+0xca>
 6ea:	5e c0       	rjmp	.+188    	; 0x7a8 <main+0x160>
 6ec:	83 30       	cpi	r24, 0x03	; 3
 6ee:	c9 f1       	breq	.+114    	; 0x762 <main+0x11a>
 6f0:	84 30       	cpi	r24, 0x04	; 4
 6f2:	09 f4       	brne	.+2      	; 0x6f6 <main+0xae>
 6f4:	4a c0       	rjmp	.+148    	; 0x78a <main+0x142>
 6f6:	58 c0       	rjmp	.+176    	; 0x7a8 <main+0x160>
                    {
                    case 0:                     // Ausgabe Software Version
                    if(CONTROLLWORD[4] == ADR485) // CRC CHECK 
 6f8:	f1 01       	movw	r30, r2
 6fa:	80 81       	ld	r24, Z
 6fc:	8d 30       	cpi	r24, 0x0D	; 13
 6fe:	09 f0       	breq	.+2      	; 0x702 <main+0xba>
 700:	53 c0       	rjmp	.+166    	; 0x7a8 <main+0x160>
                        {
                        putstring("Version 0.2");   // Ausgabe Versionstext Text
 702:	80 e2       	ldi	r24, 0x20	; 32
 704:	91 e0       	ldi	r25, 0x01	; 1
 706:	0e 94 5b 02 	call	0x4b6	; 0x4b6 <putstring>
                        UART_SendByte(10);               // Ausgabe Return
 70a:	8a e0       	ldi	r24, 0x0A	; 10
 70c:	0e 94 49 02 	call	0x492	; 0x492 <UART_SendByte>
 710:	4b c0       	rjmp	.+150    	; 0x7a8 <main+0x160>
                        }                                // DEBUG
                    break; //END CASE0

                    case 1:
                    if(CONTROLLWORD[4] == ADR485)       // CRC CHECK
 712:	f1 01       	movw	r30, r2
 714:	80 81       	ld	r24, Z
 716:	8d 30       	cpi	r24, 0x0D	; 13
 718:	09 f0       	breq	.+2      	; 0x71c <main+0xd4>
 71a:	46 c0       	rjmp	.+140    	; 0x7a8 <main+0x160>
                        {
                        putstring("Zeiger:");            // Ausgabe Text
 71c:	8c e2       	ldi	r24, 0x2C	; 44
 71e:	91 e0       	ldi	r25, 0x01	; 1
 720:	0e 94 5b 02 	call	0x4b6	; 0x4b6 <putstring>
                        errorcodeu(CONTROLLWORD[3]);	// Test 
 724:	e1 ea       	ldi	r30, 0xA1	; 161
 726:	f2 e0       	ldi	r31, 0x02	; 2
 728:	80 81       	ld	r24, Z
 72a:	0e 94 6a 02 	call	0x4d4	; 0x4d4 <errorcodeu>
						UART_SendByte(10);              // Ausgabe Return
 72e:	8a e0       	ldi	r24, 0x0A	; 10
 730:	0e 94 49 02 	call	0x492	; 0x492 <UART_SendByte>
                        drehenr(CONTROLLWORD[3]);		// DEBUG
 734:	e1 ea       	ldi	r30, 0xA1	; 161
 736:	f2 e0       	ldi	r31, 0x02	; 2
 738:	80 81       	ld	r24, Z
 73a:	0e 94 c7 00 	call	0x18e	; 0x18e <drehenr>
 73e:	34 c0       	rjmp	.+104    	; 0x7a8 <main+0x160>
                        }
                    break; //END CASE1

                    case 2:               
                    if(CONTROLLWORD[4] == ADR485)       // CRC CHECK
 740:	f1 01       	movw	r30, r2
 742:	80 81       	ld	r24, Z
 744:	8d 30       	cpi	r24, 0x0D	; 13
 746:	81 f5       	brne	.+96     	; 0x7a8 <main+0x160>
                        {
                        putstring("TEMPANZEIGE AUS");   // Ausgabe Text
 748:	84 e3       	ldi	r24, 0x34	; 52
 74a:	91 e0       	ldi	r25, 0x01	; 1
 74c:	0e 94 5b 02 	call	0x4b6	; 0x4b6 <putstring>
                        UART_SendByte(10);              // Ausgabe Return
 750:	8a e0       	ldi	r24, 0x0A	; 10
 752:	0e 94 49 02 	call	0x492	; 0x492 <UART_SendByte>
                        sbi(TEMP_OFF,FLAGS);			// Temperaturanzeige AUS 
 756:	80 91 a9 02 	lds	r24, 0x02A9
 75a:	84 60       	ori	r24, 0x04	; 4
 75c:	80 93 a9 02 	sts	0x02A9, r24
 760:	23 c0       	rjmp	.+70     	; 0x7a8 <main+0x160>
                        }
                    break; //END CASE2

                    case 3: 
                    if(CONTROLLWORD[4] == ADR485)       // CRC CHECK
 762:	f1 01       	movw	r30, r2
 764:	80 81       	ld	r24, Z
 766:	8d 30       	cpi	r24, 0x0D	; 13
 768:	f9 f4       	brne	.+62     	; 0x7a8 <main+0x160>
                        {
                        UART_SendByte(10);              // Ausgabe Return
 76a:	8a e0       	ldi	r24, 0x0A	; 10
 76c:	0e 94 49 02 	call	0x492	; 0x492 <UART_SendByte>
                        putstring("Wuerfel Spezialmode 7"); // Ausgabe Text
 770:	84 e4       	ldi	r24, 0x44	; 68
 772:	91 e0       	ldi	r25, 0x01	; 1
 774:	0e 94 5b 02 	call	0x4b6	; 0x4b6 <putstring>
						sbi(WUERFEL_7,FLAGS);			// Wuerfelspezialmode 7
 778:	80 91 a9 02 	lds	r24, 0x02A9
 77c:	82 60       	ori	r24, 0x02	; 2
 77e:	80 93 a9 02 	sts	0x02A9, r24
                        UART_SendByte(10);              // Ausgabe Return
 782:	8a e0       	ldi	r24, 0x0A	; 10
 784:	0e 94 49 02 	call	0x492	; 0x492 <UART_SendByte>
 788:	0f c0       	rjmp	.+30     	; 0x7a8 <main+0x160>
                        }
                    break; //END CASE3

                    case 4:                             
                    if(CONTROLLWORD[4] == ADR485)      // CRC CHECK
 78a:	f1 01       	movw	r30, r2
 78c:	80 81       	ld	r24, Z
 78e:	8d 30       	cpi	r24, 0x0D	; 13
 790:	59 f4       	brne	.+22     	; 0x7a8 <main+0x160>
                    {
                        //ztemp = zufall;                // Zufahlszahl
                        UART_SendByte(10);             // Ausgabe Return
 792:	8a e0       	ldi	r24, 0x0A	; 10
 794:	0e 94 49 02 	call	0x492	; 0x492 <UART_SendByte>
                        putstring("drehen an: ");      // Ausgabe Versionstext Text
 798:	8a e5       	ldi	r24, 0x5A	; 90
 79a:	91 e0       	ldi	r25, 0x01	; 1
 79c:	0e 94 5b 02 	call	0x4b6	; 0x4b6 <putstring>
                        //drehaktiv = CONTROLLWORD[3];
						drehaktiv = zufall;
 7a0:	80 91 67 01 	lds	r24, 0x0167
 7a4:	80 93 ad 02 	sts	0x02AD, r24

/*****************************************************************************
 startet den Analogdigitalwandler
 zum Auslesen des int Temp Sensor                                                                    
******************************************************************************/
         if (counter == 20)
 7a8:	80 91 a8 02 	lds	r24, 0x02A8
 7ac:	84 31       	cpi	r24, 0x14	; 20
 7ae:	49 f4       	brne	.+18     	; 0x7c2 <main+0x17a>
              {
              sbi(6,ADCSRA);
 7b0:	f8 01       	movw	r30, r16
 7b2:	80 81       	ld	r24, Z
 7b4:	80 64       	ori	r24, 0x40	; 64
 7b6:	80 83       	st	Z, r24
              counter++;
 7b8:	80 91 a8 02 	lds	r24, 0x02A8
 7bc:	8f 5f       	subi	r24, 0xFF	; 255
 7be:	80 93 a8 02 	sts	0x02A8, r24
              }

/******************************************************************************
Auslesen der Temperaturdaten aus den AD Wandler
******************************************************************************/
         if (counter == 70 )
 7c2:	80 91 a8 02 	lds	r24, 0x02A8
 7c6:	86 34       	cpi	r24, 0x46	; 70
 7c8:	59 f4       	brne	.+22     	; 0x7e0 <main+0x198>
              {
	          templ = ADCL;
 7ca:	f5 01       	movw	r30, r10
 7cc:	c0 80       	ld	r12, Z
	          temph = ADCH;
 7ce:	f4 01       	movw	r30, r8
 7d0:	80 81       	ld	r24, Z
	          temperaturdaten = HILO(temph,templ);
 7d2:	d1 2c       	mov	r13, r1
 7d4:	d8 2a       	or	r13, r24
              counter++;
 7d6:	80 91 a8 02 	lds	r24, 0x02A8
 7da:	8f 5f       	subi	r24, 0xFF	; 255
 7dc:	80 93 a8 02 	sts	0x02A8, r24
/******************************************************************************
Ausgabe der Temperaturdaten auf das LED Band
Ist Temp OFF gesetzt werden die TEMP LEDS geloescht 
FLAG TEMPISOFF wird gesetzt damit das LED Temperaturband nur einmal ruckgesetzt wird                                                                 
******************************************************************************/
         if ( qbi(TEMP_OFF,FLAGS) )
 7e0:	80 91 a9 02 	lds	r24, 0x02A9
 7e4:	82 ff       	sbrs	r24, 2
 7e6:	0c c0       	rjmp	.+24     	; 0x800 <main+0x1b8>
			{
			if (!qbi(TEMPISOFF,FLAGS))
 7e8:	83 fd       	sbrc	r24, 3
 7ea:	18 c0       	rjmp	.+48     	; 0x81c <main+0x1d4>
			   {
				sbi(TEMPISOFF,FLAGS);   
 7ec:	88 60       	ori	r24, 0x08	; 8
 7ee:	80 93 a9 02 	sts	0x02A9, r24
 7f2:	f3 01       	movw	r30, r6
				for (uint8_t step = 0; step <= 10 ; step++)
                    {
					LED_TASK[step][0]=0;
 7f4:	10 82       	st	Z, r1
 7f6:	32 96       	adiw	r30, 0x02	; 2
         if ( qbi(TEMP_OFF,FLAGS) )
			{
			if (!qbi(TEMPISOFF,FLAGS))
			   {
				sbi(TEMPISOFF,FLAGS);   
				for (uint8_t step = 0; step <= 10 ; step++)
 7f8:	ec 17       	cp	r30, r28
 7fa:	fd 07       	cpc	r31, r29
 7fc:	d9 f7       	brne	.-10     	; 0x7f4 <main+0x1ac>
 7fe:	0e c0       	rjmp	.+28     	; 0x81c <main+0x1d4>
                    }   
			   }
			}
		 else
			{
		 if (counter == 200)
 800:	80 91 a8 02 	lds	r24, 0x02A8
 804:	88 3c       	cpi	r24, 0xC8	; 200
 806:	51 f4       	brne	.+20     	; 0x81c <main+0x1d4>
              {
	          ledband(temperaturdaten,330);
 808:	6a e4       	ldi	r22, 0x4A	; 74
 80a:	71 e0       	ldi	r23, 0x01	; 1
 80c:	c6 01       	movw	r24, r12
 80e:	0e 94 0e 01 	call	0x21c	; 0x21c <ledband>
	          counter++;
 812:	80 91 a8 02 	lds	r24, 0x02A8
 816:	8f 5f       	subi	r24, 0xFF	; 255
 818:	80 93 a8 02 	sts	0x02A8, r24
Uebergabe der Geschwindigkeit beim Wuerfeln
Uebergabe der Zufahlszahl fuer den Wuerfel
Beim Start Taster muss noch die Anzahl der Umlaeufe drehaktiv festgelegt werden
drehaktiv = zufall oder man zaehlt die Taster Prellungen
******************************************************************************/	
         if (drehaktiv)
 81c:	80 91 ad 02 	lds	r24, 0x02AD
 820:	88 23       	and	r24, r24
 822:	09 f4       	brne	.+2      	; 0x826 <main+0x1de>
 824:	4b cf       	rjmp	.-362    	; 0x6bc <main+0x74>
              {
              wuerfellos(3,zufall);                  
 826:	60 91 67 01 	lds	r22, 0x0167
 82a:	83 e0       	ldi	r24, 0x03	; 3
 82c:	0e 94 8d 02 	call	0x51a	; 0x51a <wuerfellos>
 830:	45 cf       	rjmp	.-374    	; 0x6bc <main+0x74>

00000832 <__vector_16>:
INTERRUPT Timer 0 Timerueberlauf
Einsprung alle XX ms
Dieser Timer wird fuer den Multiplexer genutzt
*******************************************************************************/
ISR(TIMER0_OVF_vect)
{
 832:	1f 92       	push	r1
 834:	0f 92       	push	r0
 836:	0f b6       	in	r0, 0x3f	; 63
 838:	0f 92       	push	r0
 83a:	11 24       	eor	r1, r1
 83c:	2f 93       	push	r18
 83e:	3f 93       	push	r19
 840:	4f 93       	push	r20
 842:	5f 93       	push	r21
 844:	6f 93       	push	r22
 846:	7f 93       	push	r23
 848:	8f 93       	push	r24
 84a:	9f 93       	push	r25
 84c:	af 93       	push	r26
 84e:	bf 93       	push	r27
 850:	ef 93       	push	r30
 852:	ff 93       	push	r31


if ( (LED_TASK[LED_Timer][0]) && ( taskcount < 1 ) )
 854:	80 91 a2 01 	lds	r24, 0x01A2
 858:	e8 2f       	mov	r30, r24
 85a:	f0 e0       	ldi	r31, 0x00	; 0
 85c:	ee 0f       	add	r30, r30
 85e:	ff 1f       	adc	r31, r31
 860:	e7 58       	subi	r30, 0x87	; 135
 862:	fe 4f       	sbci	r31, 0xFE	; 254
 864:	90 81       	ld	r25, Z
 866:	99 23       	and	r25, r25
 868:	39 f0       	breq	.+14     	; 0x878 <__vector_16+0x46>
 86a:	90 91 a1 01 	lds	r25, 0x01A1
 86e:	91 11       	cpse	r25, r1
 870:	03 c0       	rjmp	.+6      	; 0x878 <__vector_16+0x46>
    {
    zeilenwahl(LED_Timer);  // LED Ein
 872:	0e 94 43 01 	call	0x286	; 0x286 <zeilenwahl>
 876:	03 c0       	rjmp	.+6      	; 0x87e <__vector_16+0x4c>
    }
else
    {
    zeilenwahl(0);          // LED Aus 
 878:	80 e0       	ldi	r24, 0x00	; 0
 87a:	0e 94 43 01 	call	0x286	; 0x286 <zeilenwahl>
    }
taskcount++;
 87e:	20 91 a1 01 	lds	r18, 0x01A1
 882:	2f 5f       	subi	r18, 0xFF	; 255
 884:	20 93 a1 01 	sts	0x01A1, r18
if (taskcount > (MAX_HELL -LED_HELLIGKEIT))
 888:	30 e0       	ldi	r19, 0x00	; 0
 88a:	40 91 78 01 	lds	r20, 0x0178
 88e:	81 e1       	ldi	r24, 0x11	; 17
 890:	90 e0       	ldi	r25, 0x00	; 0
 892:	84 1b       	sub	r24, r20
 894:	91 09       	sbc	r25, r1
 896:	82 17       	cp	r24, r18
 898:	93 07       	cpc	r25, r19
 89a:	14 f4       	brge	.+4      	; 0x8a0 <__vector_16+0x6e>
    {
    taskcount = 0;
 89c:	10 92 a1 01 	sts	0x01A1, r1
    }

LED_Timer++;
 8a0:	80 91 a2 01 	lds	r24, 0x01A2
 8a4:	8f 5f       	subi	r24, 0xFF	; 255
if (LED_Timer > LED_ANZAHL)
 8a6:	84 31       	cpi	r24, 0x14	; 20
 8a8:	18 f4       	brcc	.+6      	; 0x8b0 <__vector_16+0x7e>
if (taskcount > (MAX_HELL -LED_HELLIGKEIT))
    {
    taskcount = 0;
    }

LED_Timer++;
 8aa:	80 93 a2 01 	sts	0x01A2, r24
 8ae:	03 c0       	rjmp	.+6      	; 0x8b6 <__vector_16+0x84>
if (LED_Timer > LED_ANZAHL)
    {
    LED_Timer = 1;
 8b0:	81 e0       	ldi	r24, 0x01	; 1
 8b2:	80 93 a2 01 	sts	0x01A2, r24
    }


}
 8b6:	ff 91       	pop	r31
 8b8:	ef 91       	pop	r30
 8ba:	bf 91       	pop	r27
 8bc:	af 91       	pop	r26
 8be:	9f 91       	pop	r25
 8c0:	8f 91       	pop	r24
 8c2:	7f 91       	pop	r23
 8c4:	6f 91       	pop	r22
 8c6:	5f 91       	pop	r21
 8c8:	4f 91       	pop	r20
 8ca:	3f 91       	pop	r19
 8cc:	2f 91       	pop	r18
 8ce:	0f 90       	pop	r0
 8d0:	0f be       	out	0x3f, r0	; 63
 8d2:	0f 90       	pop	r0
 8d4:	1f 90       	pop	r1
 8d6:	18 95       	reti

000008d8 <__vector_14>:
/******************************************************************************
INTERRUPT Timer 0 Vergleich A 
Wird nicht genutzt
******************************************************************************/
ISR (TIMER0_COMPA_vect)
{
 8d8:	1f 92       	push	r1
 8da:	0f 92       	push	r0
 8dc:	0f b6       	in	r0, 0x3f	; 63
 8de:	0f 92       	push	r0
 8e0:	11 24       	eor	r1, r1

}
 8e2:	0f 90       	pop	r0
 8e4:	0f be       	out	0x3f, r0	; 63
 8e6:	0f 90       	pop	r0
 8e8:	1f 90       	pop	r1
 8ea:	18 95       	reti

000008ec <__vector_9>:
Setzt UART nach Zeit X wieder in den Empfangsmodus 
Zufallsgenerator fuer den Wuerfel
******************************************************************************/

ISR(TIMER2_OVF_vect)
{
 8ec:	1f 92       	push	r1
 8ee:	0f 92       	push	r0
 8f0:	0f b6       	in	r0, 0x3f	; 63
 8f2:	0f 92       	push	r0
 8f4:	11 24       	eor	r1, r1
 8f6:	8f 93       	push	r24
 8f8:	9f 93       	push	r25
    
// Funktion zum Ruecksetzen des aktiven Sendekanals der Schnittstelle RS485
if(rucksetzcount)
 8fa:	80 91 77 01 	lds	r24, 0x0177
 8fe:	88 23       	and	r24, r24
 900:	51 f0       	breq	.+20     	; 0x916 <__vector_9+0x2a>
    {
    if(rucksetzcount == 1)
 902:	80 91 77 01 	lds	r24, 0x0177
 906:	81 30       	cpi	r24, 0x01	; 1
 908:	09 f4       	brne	.+2      	; 0x90c <__vector_9+0x20>
        {
        SENDEN_INAKTIV;
 90a:	45 98       	cbi	0x08, 5	; 8
        }
    rucksetzcount--;
 90c:	80 91 77 01 	lds	r24, 0x0177
 910:	81 50       	subi	r24, 0x01	; 1
 912:	80 93 77 01 	sts	0x0177, r24
    }
	
// Test Zufallsgenerator fuer den Wuerfel	

if ( qbi(WUERFEL_7,FLAGS) )
 916:	80 91 a9 02 	lds	r24, 0x02A9
 91a:	81 ff       	sbrs	r24, 1
 91c:	07 c0       	rjmp	.+14     	; 0x92c <__vector_9+0x40>
     {
     if (zufall >= 7)
 91e:	80 91 67 01 	lds	r24, 0x0167
 922:	87 30       	cpi	r24, 0x07	; 7
 924:	48 f0       	brcs	.+18     	; 0x938 <__vector_9+0x4c>
         {
	     zufall = 0;
 926:	10 92 67 01 	sts	0x0167, r1
 92a:	06 c0       	rjmp	.+12     	; 0x938 <__vector_9+0x4c>
         }
     }
else
	{
    if (zufall >= 6)
 92c:	80 91 67 01 	lds	r24, 0x0167
 930:	86 30       	cpi	r24, 0x06	; 6
 932:	10 f0       	brcs	.+4      	; 0x938 <__vector_9+0x4c>
          {
          zufall = 0;
 934:	10 92 67 01 	sts	0x0167, r1
          }	   
    }
	
	
	
zufall++;
 938:	80 91 67 01 	lds	r24, 0x0167
 93c:	8f 5f       	subi	r24, 0xFF	; 255
 93e:	80 93 67 01 	sts	0x0167, r24
counter++;
 942:	80 91 a8 02 	lds	r24, 0x02A8
 946:	8f 5f       	subi	r24, 0xFF	; 255
 948:	80 93 a8 02 	sts	0x02A8, r24
wzeiger++;
 94c:	80 91 aa 02 	lds	r24, 0x02AA
 950:	90 91 ab 02 	lds	r25, 0x02AB
 954:	01 96       	adiw	r24, 0x01	; 1
 956:	90 93 ab 02 	sts	0x02AB, r25
 95a:	80 93 aa 02 	sts	0x02AA, r24
}
 95e:	9f 91       	pop	r25
 960:	8f 91       	pop	r24
 962:	0f 90       	pop	r0
 964:	0f be       	out	0x3f, r0	; 63
 966:	0f 90       	pop	r0
 968:	1f 90       	pop	r1
 96a:	18 95       	reti

0000096c <__vector_18>:
INTERRUPT ROUTINE fuer UART, schreibt empfangenes Zeichen in den BUFFER
Empfangene Zeichen werden in den Puffer geschrieben 
Ist der Zeiger am Ende des Puffesr wird dieser an den Anfang gesetzt
******************************************************************************/
ISR(USART_RX_vect)
{
 96c:	1f 92       	push	r1
 96e:	0f 92       	push	r0
 970:	0f b6       	in	r0, 0x3f	; 63
 972:	0f 92       	push	r0
 974:	11 24       	eor	r1, r1
 976:	8f 93       	push	r24
 978:	9f 93       	push	r25
 97a:	ef 93       	push	r30
 97c:	ff 93       	push	r31

puffer[schreibzeiger]=UDR0;
 97e:	80 91 68 01 	lds	r24, 0x0168
 982:	90 91 c6 00 	lds	r25, 0x00C6
 986:	e8 2f       	mov	r30, r24
 988:	f0 e0       	ldi	r31, 0x00	; 0
 98a:	ec 55       	subi	r30, 0x5C	; 92
 98c:	fe 4f       	sbci	r31, 0xFE	; 254
 98e:	90 83       	st	Z, r25
schreibzeiger++;
 990:	8f 5f       	subi	r24, 0xFF	; 255
if(schreibzeiger==PUFFER_GROESSE) schreibzeiger=0;
 992:	8a 3f       	cpi	r24, 0xFA	; 250
 994:	19 f0       	breq	.+6      	; 0x99c <__vector_18+0x30>
******************************************************************************/
ISR(USART_RX_vect)
{

puffer[schreibzeiger]=UDR0;
schreibzeiger++;
 996:	80 93 68 01 	sts	0x0168, r24
 99a:	02 c0       	rjmp	.+4      	; 0x9a0 <__vector_18+0x34>
if(schreibzeiger==PUFFER_GROESSE) schreibzeiger=0;
 99c:	10 92 68 01 	sts	0x0168, r1
}
 9a0:	ff 91       	pop	r31
 9a2:	ef 91       	pop	r30
 9a4:	9f 91       	pop	r25
 9a6:	8f 91       	pop	r24
 9a8:	0f 90       	pop	r0
 9aa:	0f be       	out	0x3f, r0	; 63
 9ac:	0f 90       	pop	r0
 9ae:	1f 90       	pop	r1
 9b0:	18 95       	reti

000009b2 <__divmodhi4>:
 9b2:	97 fb       	bst	r25, 7
 9b4:	07 2e       	mov	r0, r23
 9b6:	16 f4       	brtc	.+4      	; 0x9bc <__divmodhi4+0xa>
 9b8:	00 94       	com	r0
 9ba:	07 d0       	rcall	.+14     	; 0x9ca <__divmodhi4_neg1>
 9bc:	77 fd       	sbrc	r23, 7
 9be:	09 d0       	rcall	.+18     	; 0x9d2 <__divmodhi4_neg2>
 9c0:	0e 94 f3 04 	call	0x9e6	; 0x9e6 <__udivmodhi4>
 9c4:	07 fc       	sbrc	r0, 7
 9c6:	05 d0       	rcall	.+10     	; 0x9d2 <__divmodhi4_neg2>
 9c8:	3e f4       	brtc	.+14     	; 0x9d8 <__divmodhi4_exit>

000009ca <__divmodhi4_neg1>:
 9ca:	90 95       	com	r25
 9cc:	81 95       	neg	r24
 9ce:	9f 4f       	sbci	r25, 0xFF	; 255
 9d0:	08 95       	ret

000009d2 <__divmodhi4_neg2>:
 9d2:	70 95       	com	r23
 9d4:	61 95       	neg	r22
 9d6:	7f 4f       	sbci	r23, 0xFF	; 255

000009d8 <__divmodhi4_exit>:
 9d8:	08 95       	ret

000009da <__tablejump2__>:
 9da:	ee 0f       	add	r30, r30
 9dc:	ff 1f       	adc	r31, r31

000009de <__tablejump__>:
 9de:	05 90       	lpm	r0, Z+
 9e0:	f4 91       	lpm	r31, Z
 9e2:	e0 2d       	mov	r30, r0
 9e4:	09 94       	ijmp

000009e6 <__udivmodhi4>:
 9e6:	aa 1b       	sub	r26, r26
 9e8:	bb 1b       	sub	r27, r27
 9ea:	51 e1       	ldi	r21, 0x11	; 17
 9ec:	07 c0       	rjmp	.+14     	; 0x9fc <__udivmodhi4_ep>

000009ee <__udivmodhi4_loop>:
 9ee:	aa 1f       	adc	r26, r26
 9f0:	bb 1f       	adc	r27, r27
 9f2:	a6 17       	cp	r26, r22
 9f4:	b7 07       	cpc	r27, r23
 9f6:	10 f0       	brcs	.+4      	; 0x9fc <__udivmodhi4_ep>
 9f8:	a6 1b       	sub	r26, r22
 9fa:	b7 0b       	sbc	r27, r23

000009fc <__udivmodhi4_ep>:
 9fc:	88 1f       	adc	r24, r24
 9fe:	99 1f       	adc	r25, r25
 a00:	5a 95       	dec	r21
 a02:	a9 f7       	brne	.-22     	; 0x9ee <__udivmodhi4_loop>
 a04:	80 95       	com	r24
 a06:	90 95       	com	r25
 a08:	bc 01       	movw	r22, r24
 a0a:	cd 01       	movw	r24, r26
 a0c:	08 95       	ret

00000a0e <_exit>:
 a0e:	f8 94       	cli

00000a10 <__stop_program>:
 a10:	ff cf       	rjmp	.-2      	; 0xa10 <__stop_program>
